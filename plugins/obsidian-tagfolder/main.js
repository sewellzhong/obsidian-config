/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD AND TERSER
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";

var __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __hasOwnProp = Object.prototype.hasOwnProperty, __typeError = msg => {
  throw TypeError(msg);
}, __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key2] = value, __export = (target, all) => {
  for (var name in all) __defProp(target, name, {
    get: all[name],
    enumerable: true
  });
}, __copyProps = (to, from, except, desc) => {
  if (from && "object" == typeof from || "function" == typeof from) for (let key2 of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key2) && key2 !== except) __defProp(to, key2, {
    get: () => from[key2],
    enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable
  });
  return to;
}, __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
  value: true
}), mod), __publicField = (obj, key2, value) => __defNormalProp(obj, "symbol" != typeof key2 ? key2 + "" : key2, value), __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg), __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), 
getter ? getter.call(obj) : member.get(obj)), __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value), __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), 
setter ? setter.call(obj, value) : member.set(obj, value), value), __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), 
method), main_exports = {};

__export(main_exports, {
  default: () => TagFolderPlugin5
});

module.exports = __toCommonJS(main_exports);

var _a, _b, import_obsidian8 = require("obsidian"), enumShowListIn = {
  "": "Sidebar",
  CURRENT_PANE: "Current pane",
  SPLIT_PANE: "New pane"
}, DEFAULT_SETTINGS = {
  displayMethod: "NAME",
  alwaysOpen: false,
  ignoreDocTags: "",
  ignoreTags: "",
  hideOnRootTags: "",
  sortType: "DISPNAME_ASC",
  sortExactFirst: false,
  sortTypeTag: "NAME_ASC",
  expandLimit: 0,
  disableNestedTags: false,
  hideItems: "NONE",
  ignoreFolders: "",
  targetFolders: "",
  scanDelay: 250,
  useTitle: true,
  reduceNestedParent: true,
  frontmatterKey: "title",
  useTagInfo: false,
  tagInfo: "pininfo.md",
  mergeRedundantCombination: false,
  useVirtualTag: false,
  useFrontmatterTagsForNewNotes: false,
  doNotSimplifyTags: false,
  overrideTagClicking: false,
  useMultiPaneList: false,
  archiveTags: "",
  disableNarrowingDown: false,
  expandUntaggedToRoot: false,
  disableDragging: false,
  linkConfig: {
    incoming: {
      enabled: true,
      key: ""
    },
    outgoing: {
      enabled: true,
      key: ""
    }
  },
  linkShowOnlyFDR: true,
  linkCombineOtherTree: true,
  showListIn: "",
  displayFolderAsTag: false
}, VIEW_TYPE_SCROLL = "tagfolder-view-scroll", EPOCH_MINUTE = 60, EPOCH_HOUR = 60 * EPOCH_MINUTE, EPOCH_DAY = 24 * EPOCH_HOUR, FRESHNESS_1 = "FRESHNESS_01", FRESHNESS_2 = "FRESHNESS_02", FRESHNESS_3 = "FRESHNESS_03", FRESHNESS_4 = "FRESHNESS_04", FRESHNESS_5 = "FRESHNESS_05", tagDispDict = {
  FRESHNESS_01: "ðŸ•",
  FRESHNESS_02: "ðŸ“–",
  FRESHNESS_03: "ðŸ“—",
  FRESHNESS_04: "ðŸ“š",
  FRESHNESS_05: "ðŸ—„",
  _VIRTUAL_TAG_FRESHNESS: "âŒ›",
  _VIRTUAL_TAG_CANVAS: "ðŸ“‹ Canvas",
  _VIRTUAL_TAG_FOLDER: "ðŸ“"
}, VIEW_TYPE_TAGFOLDER = "tagfolder-view", VIEW_TYPE_TAGFOLDER_LINK = "tagfolder-link-view", VIEW_TYPE_TAGFOLDER_LIST = "tagfolder-view-list", OrderKeyTag = {
  NAME: "Tag name",
  ITEMS: "Count of items"
}, OrderDirection = {
  ASC: "Ascending",
  DESC: "Descending"
}, OrderKeyItem = {
  DISPNAME: "Displaying name",
  NAME: "File name",
  MTIME: "Modified time",
  CTIME: "Created time",
  FULLPATH: "Fullpath of the file"
}, node_env = null == (_b = null == (_a = globalThis.process) ? void 0 : _a.env) ? void 0 : _b.NODE_ENV, dev_fallback_default = node_env && !node_env.toLowerCase().startsWith("prod"), is_array = Array.isArray, index_of = Array.prototype.indexOf, array_from = Array.from, object_keys = Object.keys, define_property = Object.defineProperty, get_descriptor = Object.getOwnPropertyDescriptor, get_descriptors = Object.getOwnPropertyDescriptors, object_prototype = Object.prototype, array_prototype = Array.prototype, get_prototype_of = Object.getPrototypeOf, is_extensible = Object.isExtensible, noop = () => {};

function run_all(arr) {
  for (var i = 0; i < arr.length; i++) arr[i]();
}

function deferred() {
  var resolve, reject;
  return {
    promise: new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    }),
    resolve,
    reject
  };
}

function to_array(value, n) {
  if (Array.isArray(value)) return value;
  if (void 0 === n || !(Symbol.iterator in value)) return Array.from(value);
  const array = [];
  for (const element2 of value) {
    array.push(element2);
    if (array.length === n) break;
  }
  return array;
}

var DERIVED = 2, EFFECT = 4, RENDER_EFFECT = 8, MANAGED_EFFECT = 1 << 24, BLOCK_EFFECT = 16, BRANCH_EFFECT = 32, ROOT_EFFECT = 64, BOUNDARY_EFFECT = 128, CONNECTED = 512, CLEAN = 1024, DIRTY = 2048, MAYBE_DIRTY = 4096, INERT = 8192, DESTROYED = 16384, EFFECT_RAN = 32768, EFFECT_TRANSPARENT = 65536, EAGER_EFFECT = 1 << 17, HEAD_EFFECT = 1 << 18, EFFECT_PRESERVED = 1 << 19, USER_EFFECT = 1 << 20, EFFECT_OFFSCREEN = 1 << 25, WAS_MARKED = 32768, REACTION_IS_UPDATING = 1 << 21, ASYNC = 1 << 22, ERROR_VALUE = 1 << 23, STATE_SYMBOL = Symbol("$state"), LEGACY_PROPS = Symbol("legacy props"), LOADING_ATTR_SYMBOL = Symbol(""), PROXY_PATH_SYMBOL = Symbol("proxy path"), STALE_REACTION = new class StaleReactionError extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "StaleReactionError");
    __publicField(this, "message", "The reaction that called `getAbortSignal()` was re-run or destroyed");
  }
}, TEXT_NODE = 3, COMMENT_NODE = 8;

function equals(value) {
  return value === this.v;
}

function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || null !== a && "object" == typeof a || "function" == typeof a;
}

function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}

function lifecycle_outside_component(name) {
  if (dev_fallback_default) {
    const error = new Error(`lifecycle_outside_component\n\`${name}(...)\` can only be used during component initialisation\nhttps://svelte.dev/e/lifecycle_outside_component`);
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}

function async_derived_orphan() {
  if (dev_fallback_default) {
    const error = new Error("async_derived_orphan\nCannot create a `$derived(...)` with an `await` expression outside of an effect tree\nhttps://svelte.dev/e/async_derived_orphan");
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/async_derived_orphan");
}

function bind_invalid_checkbox_value() {
  if (dev_fallback_default) {
    const error = new Error("bind_invalid_checkbox_value\nUsing `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead\nhttps://svelte.dev/e/bind_invalid_checkbox_value");
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/bind_invalid_checkbox_value");
}

function derived_references_self() {
  if (dev_fallback_default) {
    const error = new Error("derived_references_self\nA derived value cannot reference itself recursively\nhttps://svelte.dev/e/derived_references_self");
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/derived_references_self");
}

function effect_in_teardown(rune) {
  if (dev_fallback_default) {
    const error = new Error(`effect_in_teardown\n\`${rune}\` cannot be used inside an effect cleanup function\nhttps://svelte.dev/e/effect_in_teardown`);
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/effect_in_teardown");
}

function effect_in_unowned_derived() {
  if (dev_fallback_default) {
    const error = new Error("effect_in_unowned_derived\nEffect cannot be created inside a `$derived` value that was not itself created inside an effect\nhttps://svelte.dev/e/effect_in_unowned_derived");
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}

function effect_orphan(rune) {
  if (dev_fallback_default) {
    const error = new Error(`effect_orphan\n\`${rune}\` can only be used inside an effect (e.g. during component initialisation)\nhttps://svelte.dev/e/effect_orphan`);
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/effect_orphan");
}

function effect_update_depth_exceeded() {
  if (dev_fallback_default) {
    const error = new Error("effect_update_depth_exceeded\nMaximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state\nhttps://svelte.dev/e/effect_update_depth_exceeded");
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}

function hydration_failed() {
  if (dev_fallback_default) {
    const error = new Error("hydration_failed\nFailed to hydrate the application\nhttps://svelte.dev/e/hydration_failed");
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/hydration_failed");
}

function invalid_snippet() {
  if (dev_fallback_default) {
    const error = new Error("invalid_snippet\nCould not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}`\nhttps://svelte.dev/e/invalid_snippet");
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/invalid_snippet");
}

function props_invalid_value(key2) {
  if (dev_fallback_default) {
    const error = new Error(`props_invalid_value\nCannot do \`bind:${key2}={undefined}\` when \`${key2}\` has a fallback value\nhttps://svelte.dev/e/props_invalid_value`);
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/props_invalid_value");
}

function rune_outside_svelte(rune) {
  if (dev_fallback_default) {
    const error = new Error(`rune_outside_svelte\nThe \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files\nhttps://svelte.dev/e/rune_outside_svelte`);
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/rune_outside_svelte");
}

function set_context_after_init() {
  if (dev_fallback_default) {
    const error = new Error("set_context_after_init\n`setContext` must be called when a component first initializes, not in a subsequent effect or after an `await` expression\nhttps://svelte.dev/e/set_context_after_init");
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/set_context_after_init");
}

function state_descriptors_fixed() {
  if (dev_fallback_default) {
    const error = new Error("state_descriptors_fixed\nProperty descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.\nhttps://svelte.dev/e/state_descriptors_fixed");
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}

function state_prototype_fixed() {
  if (dev_fallback_default) {
    const error = new Error("state_prototype_fixed\nCannot set prototype of `$state` object\nhttps://svelte.dev/e/state_prototype_fixed");
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/state_prototype_fixed");
}

function state_unsafe_mutation() {
  if (dev_fallback_default) {
    const error = new Error("state_unsafe_mutation\nUpdating state inside `$derived(...)`, `$inspect(...)` or a template expression is forbidden. If the value should not be reactive, declare it without `$state`\nhttps://svelte.dev/e/state_unsafe_mutation");
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}

function svelte_boundary_reset_onerror() {
  if (dev_fallback_default) {
    const error = new Error("svelte_boundary_reset_onerror\nA `<svelte:boundary>` `reset` function cannot be called while an error is still being handled\nhttps://svelte.dev/e/svelte_boundary_reset_onerror");
    error.name = "Svelte error";
    throw error;
  } else throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}

var async_mode_flag = false, legacy_mode_flag = false, tracing_mode_flag = false, EACH_ITEM_REACTIVE = 1, EACH_INDEX_REACTIVE = 2, EACH_IS_CONTROLLED = 4, EACH_IS_ANIMATED = 8, EACH_ITEM_IMMUTABLE = 16, PROPS_IS_IMMUTABLE = 1, PROPS_IS_RUNES = 2, PROPS_IS_UPDATED = 4, PROPS_IS_BINDABLE = 8, PROPS_IS_LAZY_INITIAL = 16, TRANSITION_OUT = 2, TRANSITION_GLOBAL = 4, TEMPLATE_FRAGMENT = 1, TEMPLATE_USE_IMPORT_NODE = 2, TEMPLATE_USE_SVG = 4, TEMPLATE_USE_MATHML = 8, HYDRATION_START = "[", HYDRATION_START_ELSE = "[!", HYDRATION_END = "]", HYDRATION_ERROR = {}, ELEMENT_PRESERVE_ATTRIBUTE_CASE = 2, ELEMENT_IS_INPUT = 4, UNINITIALIZED = Symbol(), FILENAME = Symbol("filename"), NAMESPACE_HTML = "http://www.w3.org/1999/xhtml", tracing_expressions = null;

function tag(source2, label) {
  source2.label = label;
  tag_proxy(source2.v, label);
  return source2;
}

function tag_proxy(value, label) {
  var _a3;
  null == (_a3 = null == value ? void 0 : value[PROXY_PATH_SYMBOL]) || _a3.call(value, label);
  return value;
}

function get_error(label) {
  const error = new Error, stack2 = get_stack();
  if (0 === stack2.length) return null;
  stack2.unshift("\n");
  define_property(error, "stack", {
    value: stack2.join("\n")
  });
  define_property(error, "name", {
    value: label
  });
  return error;
}

function get_stack() {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 1 / 0;
  const stack2 = (new Error).stack;
  Error.stackTraceLimit = limit;
  if (!stack2) return [];
  const lines = stack2.split("\n"), new_lines = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i], posixified = line.replaceAll("\\", "/");
    if ("Error" !== line.trim()) {
      if (line.includes("validate_each_keys")) return [];
      if (!posixified.includes("svelte/src/internal") && !posixified.includes("node_modules/.vite")) new_lines.push(line);
    }
  }
  return new_lines;
}

var component_context = null;

function set_component_context(context) {
  component_context = context;
}

var dev_stack = null;

function set_dev_stack(stack2) {
  dev_stack = stack2;
}

var dev_current_component_function = null;

function set_dev_current_component_function(fn) {
  dev_current_component_function = fn;
}

function getContext(key2) {
  return get_or_init_context_map("getContext").get(key2);
}

function setContext(key2, context) {
  const context_map = get_or_init_context_map("setContext");
  if (async_mode_flag) {
    var flags2 = active_effect.f;
    if (!(!active_reaction && 0 !== (flags2 & BRANCH_EFFECT) && !component_context.i)) set_context_after_init();
  }
  context_map.set(key2, context);
  return context;
}

function push(props, runes = false, fn) {
  component_context = {
    p: component_context,
    i: false,
    c: null,
    e: null,
    s: props,
    x: null,
    l: legacy_mode_flag && !runes ? {
      s: null,
      u: null,
      $: []
    } : null
  };
  if (dev_fallback_default) {
    component_context.function = fn;
    dev_current_component_function = fn;
  }
}

function pop(component2) {
  var _a3, context = component_context, effects = context.e;
  if (null !== effects) {
    context.e = null;
    for (var fn of effects) create_user_effect(fn);
  }
  if (void 0 !== component2) context.x = component2;
  context.i = true;
  component_context = context.p;
  if (dev_fallback_default) dev_current_component_function = null != (_a3 = null == component_context ? void 0 : component_context.function) ? _a3 : null;
  return null != component2 ? component2 : {};
}

function is_runes() {
  return !legacy_mode_flag || null !== component_context && null === component_context.l;
}

function get_or_init_context_map(name) {
  var _a3;
  if (null === component_context) lifecycle_outside_component(name);
  return null != (_a3 = component_context.c) ? _a3 : component_context.c = new Map(get_parent_context(component_context) || void 0);
}

function get_parent_context(component_context2) {
  let parent = component_context2.p;
  for (;null !== parent; ) {
    const context_map = parent.c;
    if (null !== context_map) return context_map;
    parent = parent.p;
  }
  return null;
}

var micro_tasks = [];

function run_micro_tasks() {
  var tasks = micro_tasks;
  micro_tasks = [];
  run_all(tasks);
}

function queue_micro_task(fn) {
  if (0 === micro_tasks.length && !is_flushing_sync) {
    var tasks = micro_tasks;
    queueMicrotask(() => {
      if (tasks === micro_tasks) run_micro_tasks();
    });
  }
  micro_tasks.push(fn);
}

function flush_tasks() {
  for (;micro_tasks.length > 0; ) run_micro_tasks();
}

var bold = "font-weight: bold", normal = "font-weight: normal";

function await_waterfall(name, location) {
  if (dev_fallback_default) console.warn(`%c[svelte] await_waterfall\n%cAn async derived, \`${name}\` (${location}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app\nhttps://svelte.dev/e/await_waterfall`, bold, normal); else console.warn("https://svelte.dev/e/await_waterfall");
}

function hydration_attribute_changed(attribute, html2, value) {
  if (dev_fallback_default) console.warn(`%c[svelte] hydration_attribute_changed\n%cThe \`${attribute}\` attribute on \`${html2}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value\nhttps://svelte.dev/e/hydration_attribute_changed`, bold, normal); else console.warn("https://svelte.dev/e/hydration_attribute_changed");
}

function hydration_html_changed(location) {
  if (dev_fallback_default) console.warn(`%c[svelte] hydration_html_changed\n%c${location ? `The value of an \`{@html ...}\` block ${location} changed between server and client renders. The client value will be ignored in favour of the server value` : "The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value"}\nhttps://svelte.dev/e/hydration_html_changed`, bold, normal); else console.warn("https://svelte.dev/e/hydration_html_changed");
}

function hydration_mismatch(location) {
  if (dev_fallback_default) console.warn(`%c[svelte] hydration_mismatch\n%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : "Hydration failed because the initial UI does not match what was rendered on the server"}\nhttps://svelte.dev/e/hydration_mismatch`, bold, normal); else console.warn("https://svelte.dev/e/hydration_mismatch");
}

function lifecycle_double_unmount() {
  if (dev_fallback_default) console.warn("%c[svelte] lifecycle_double_unmount\n%cTried to unmount a component that was not mounted\nhttps://svelte.dev/e/lifecycle_double_unmount", bold, normal); else console.warn("https://svelte.dev/e/lifecycle_double_unmount");
}

function state_proxy_equality_mismatch(operator) {
  if (dev_fallback_default) console.warn(`%c[svelte] state_proxy_equality_mismatch\n%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results\nhttps://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal); else console.warn("https://svelte.dev/e/state_proxy_equality_mismatch");
}

function state_proxy_unmount() {
  if (dev_fallback_default) console.warn("%c[svelte] state_proxy_unmount\n%cTried to unmount a state proxy, rather than a component\nhttps://svelte.dev/e/state_proxy_unmount", bold, normal); else console.warn("https://svelte.dev/e/state_proxy_unmount");
}

function svelte_boundary_reset_noop() {
  if (dev_fallback_default) console.warn("%c[svelte] svelte_boundary_reset_noop\n%cA `<svelte:boundary>` `reset` function only resets the boundary the first time it is called\nhttps://svelte.dev/e/svelte_boundary_reset_noop", bold, normal); else console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}

var hydrate_node, hydrating = false;

function set_hydrating(value) {
  hydrating = value;
}

function set_hydrate_node(node) {
  if (null === node) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}

function hydrate_next() {
  return set_hydrate_node(get_next_sibling(hydrate_node));
}

function reset(node) {
  if (hydrating) {
    if (null !== get_next_sibling(hydrate_node)) {
      hydration_mismatch();
      throw HYDRATION_ERROR;
    }
    hydrate_node = node;
  }
}

function next(count = 1) {
  if (hydrating) {
    for (var i = count, node = hydrate_node; i--; ) node = get_next_sibling(node);
    hydrate_node = node;
  }
}

function skip_nodes(remove = true) {
  for (var depth = 0, node = hydrate_node; ;) {
    if (node.nodeType === COMMENT_NODE) {
      var data = node.data;
      if (data === HYDRATION_END) {
        if (0 === depth) return node;
        depth -= 1;
      } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) depth += 1;
    }
    var next2 = get_next_sibling(node);
    if (remove) node.remove();
    node = next2;
  }
}

function read_hydration_instruction(node) {
  if (!node || node.nodeType !== COMMENT_NODE) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return node.data;
}

var regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;

function proxy(value) {
  if ("object" != typeof value || null === value || STATE_SYMBOL in value) return value;
  const prototype = get_prototype_of(value);
  if (prototype !== object_prototype && prototype !== array_prototype) return value;
  var sources = new Map, is_proxied_array = is_array(value), version = state(0), stack2 = dev_fallback_default && tracing_mode_flag ? get_error("created at") : null, parent_version = update_version, with_parent = fn => {
    if (update_version === parent_version) return fn();
    var reaction = active_reaction, version2 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn();
    set_active_reaction(reaction);
    set_update_version(version2);
    return result;
  };
  if (is_proxied_array) {
    sources.set("length", state(value.length, stack2));
    if (dev_fallback_default) value = inspectable_array(value);
  }
  var path = "";
  let updating = false;
  function update_path(new_path) {
    if (!updating) {
      updating = true;
      tag(version, `${path = new_path} version`);
      for (const [prop2, source2] of sources) tag(source2, get_label(path, prop2));
      updating = false;
    }
  }
  return new Proxy(value, {
    defineProperty(_, prop2, descriptor) {
      if (!("value" in descriptor) || false === descriptor.configurable || false === descriptor.enumerable || false === descriptor.writable) state_descriptors_fixed();
      var s = sources.get(prop2);
      if (void 0 === s) s = with_parent(() => {
        var s2 = state(descriptor.value, stack2);
        sources.set(prop2, s2);
        if (dev_fallback_default && "string" == typeof prop2) tag(s2, get_label(path, prop2));
        return s2;
      }); else set(s, descriptor.value, true);
      return true;
    },
    deleteProperty(target, prop2) {
      var s = sources.get(prop2);
      if (void 0 === s) {
        if (prop2 in target) {
          const s2 = with_parent(() => state(UNINITIALIZED, stack2));
          sources.set(prop2, s2);
          increment(version);
          if (dev_fallback_default) tag(s2, get_label(path, prop2));
        }
      } else {
        set(s, UNINITIALIZED);
        increment(version);
      }
      return true;
    },
    get(target, prop2, receiver) {
      var _a3;
      if (prop2 === STATE_SYMBOL) return value;
      if (dev_fallback_default && prop2 === PROXY_PATH_SYMBOL) return update_path;
      var s = sources.get(prop2), exists = prop2 in target;
      if (void 0 === s && (!exists || (null == (_a3 = get_descriptor(target, prop2)) ? void 0 : _a3.writable))) {
        s = with_parent(() => {
          var s2 = state(proxy(exists ? target[prop2] : UNINITIALIZED), stack2);
          if (dev_fallback_default) tag(s2, get_label(path, prop2));
          return s2;
        });
        sources.set(prop2, s);
      }
      if (void 0 !== s) {
        var v = get(s);
        return v === UNINITIALIZED ? void 0 : v;
      }
      return Reflect.get(target, prop2, receiver);
    },
    getOwnPropertyDescriptor(target, prop2) {
      var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
      if (descriptor && "value" in descriptor) {
        var s = sources.get(prop2);
        if (s) descriptor.value = get(s);
      } else if (void 0 === descriptor) {
        var source2 = sources.get(prop2), value2 = null == source2 ? void 0 : source2.v;
        if (void 0 !== source2 && value2 !== UNINITIALIZED) return {
          enumerable: true,
          configurable: true,
          value: value2,
          writable: true
        };
      }
      return descriptor;
    },
    has(target, prop2) {
      var _a3;
      if (prop2 === STATE_SYMBOL) return true;
      var s = sources.get(prop2), has = void 0 !== s && s.v !== UNINITIALIZED || Reflect.has(target, prop2);
      if (void 0 !== s || null !== active_effect && (!has || (null == (_a3 = get_descriptor(target, prop2)) ? void 0 : _a3.writable))) {
        if (void 0 === s) {
          s = with_parent(() => {
            var s2 = state(has ? proxy(target[prop2]) : UNINITIALIZED, stack2);
            if (dev_fallback_default) tag(s2, get_label(path, prop2));
            return s2;
          });
          sources.set(prop2, s);
        }
        if (get(s) === UNINITIALIZED) return false;
      }
      return has;
    },
    set(target, prop2, value2, receiver) {
      var _a3, s = sources.get(prop2), has = prop2 in target;
      if (is_proxied_array && "length" === prop2) for (var i = value2; i < s.v; i += 1) {
        var other_s = sources.get(i + "");
        if (void 0 !== other_s) set(other_s, UNINITIALIZED); else if (i in target) {
          other_s = with_parent(() => state(UNINITIALIZED, stack2));
          sources.set(i + "", other_s);
          if (dev_fallback_default) tag(other_s, get_label(path, i));
        }
      }
      if (void 0 === s) {
        if (!has || (null == (_a3 = get_descriptor(target, prop2)) ? void 0 : _a3.writable)) {
          s = with_parent(() => state(void 0, stack2));
          if (dev_fallback_default) tag(s, get_label(path, prop2));
          set(s, proxy(value2));
          sources.set(prop2, s);
        }
      } else {
        has = s.v !== UNINITIALIZED;
        set(s, with_parent(() => proxy(value2)));
      }
      var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
      if (null == descriptor ? void 0 : descriptor.set) descriptor.set.call(receiver, value2);
      if (!has) {
        if (is_proxied_array && "string" == typeof prop2) {
          var ls = sources.get("length"), n = Number(prop2);
          if (Number.isInteger(n) && n >= ls.v) set(ls, n + 1);
        }
        increment(version);
      }
      return true;
    },
    ownKeys(target) {
      get(version);
      var own_keys = Reflect.ownKeys(target).filter(key3 => {
        var source3 = sources.get(key3);
        return void 0 === source3 || source3.v !== UNINITIALIZED;
      });
      for (var [key2, source2] of sources) if (source2.v !== UNINITIALIZED && !(key2 in target)) own_keys.push(key2);
      return own_keys;
    },
    setPrototypeOf() {
      state_prototype_fixed();
    }
  });
}

function get_label(path, prop2) {
  var _a3;
  if ("symbol" == typeof prop2) return `${path}[Symbol(${null != (_a3 = prop2.description) ? _a3 : ""})]`;
  if (regex_is_valid_identifier.test(prop2)) return `${path}.${prop2}`; else return /^\d+$/.test(prop2) ? `${path}[${prop2}]` : `${path}['${prop2}']`;
}

function get_proxied_value(value) {
  try {
    if (null !== value && "object" == typeof value && STATE_SYMBOL in value) return value[STATE_SYMBOL];
  } catch (e) {}
  return value;
}

var $window, $document, is_firefox, first_child_getter, next_sibling_getter, ARRAY_MUTATING_METHODS = new Set([ "copyWithin", "fill", "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ]);

function inspectable_array(array) {
  return new Proxy(array, {
    get(target, prop2, receiver) {
      var value = Reflect.get(target, prop2, receiver);
      if (!ARRAY_MUTATING_METHODS.has(prop2)) return value; else return function(...args) {
        set_eager_effects_deferred();
        var result = value.apply(this, args);
        flush_eager_effects();
        return result;
      };
    }
  });
}

function init_array_prototype_warnings() {
  const array_prototype2 = Array.prototype, cleanup = Array.__svelte_cleanup;
  if (cleanup) cleanup();
  const {indexOf, lastIndexOf, includes} = array_prototype2;
  array_prototype2.indexOf = function(item, from_index) {
    const index2 = indexOf.call(this, item, from_index);
    if (-1 === index2) for (let i = null != from_index ? from_index : 0; i < this.length; i += 1) if (get_proxied_value(this[i]) === item) {
      state_proxy_equality_mismatch("array.indexOf(...)");
      break;
    }
    return index2;
  };
  array_prototype2.lastIndexOf = function(item, from_index) {
    const index2 = lastIndexOf.call(this, item, null != from_index ? from_index : this.length - 1);
    if (-1 === index2) for (let i = 0; i <= (null != from_index ? from_index : this.length - 1); i += 1) if (get_proxied_value(this[i]) === item) {
      state_proxy_equality_mismatch("array.lastIndexOf(...)");
      break;
    }
    return index2;
  };
  array_prototype2.includes = function(item, from_index) {
    const has = includes.call(this, item, from_index);
    if (!has) for (let i = 0; i < this.length; i += 1) if (get_proxied_value(this[i]) === item) {
      state_proxy_equality_mismatch("array.includes(...)");
      break;
    }
    return has;
  };
  Array.__svelte_cleanup = () => {
    array_prototype2.indexOf = indexOf;
    array_prototype2.lastIndexOf = lastIndexOf;
    array_prototype2.includes = includes;
  };
}

function init_operations() {
  if (void 0 === $window) {
    $window = window;
    $document = document;
    is_firefox = /Firefox/.test(navigator.userAgent);
    var element_prototype = Element.prototype, node_prototype = Node.prototype, text_prototype = Text.prototype;
    first_child_getter = get_descriptor(node_prototype, "firstChild").get;
    next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
    if (is_extensible(element_prototype)) {
      element_prototype.__click = void 0;
      element_prototype.__className = void 0;
      element_prototype.__attributes = null;
      element_prototype.__style = void 0;
      element_prototype.__e = void 0;
    }
    if (is_extensible(text_prototype)) text_prototype.__t = void 0;
    if (dev_fallback_default) {
      element_prototype.__svelte_meta = null;
      init_array_prototype_warnings();
    }
  }
}

function create_text(value = "") {
  return document.createTextNode(value);
}

function get_first_child(node) {
  return first_child_getter.call(node);
}

function get_next_sibling(node) {
  return next_sibling_getter.call(node);
}

function child(node, is_text) {
  if (!hydrating) return get_first_child(node);
  var child2 = get_first_child(hydrate_node);
  if (null === child2) child2 = hydrate_node.appendChild(create_text()); else if (is_text && child2.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    null == child2 || child2.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(child2);
  return child2;
}

function first_child(node, is_text = false) {
  var _a3, _b3;
  if (!hydrating) {
    var first = get_first_child(node);
    if (first instanceof Comment && "" === first.data) return get_next_sibling(first); else return first;
  }
  if (is_text && (null == (_a3 = hydrate_node) ? void 0 : _a3.nodeType) !== TEXT_NODE) {
    var text2 = create_text();
    null == (_b3 = hydrate_node) || _b3.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  return hydrate_node;
}

function sibling(node, count = 1, is_text = false) {
  let next_sibling = hydrating ? hydrate_node : node;
  for (var last_sibling; count--; ) {
    last_sibling = next_sibling;
    next_sibling = get_next_sibling(next_sibling);
  }
  if (!hydrating) return next_sibling;
  if (is_text && (null == next_sibling ? void 0 : next_sibling.nodeType) !== TEXT_NODE) {
    var text2 = create_text();
    if (null === next_sibling) null == last_sibling || last_sibling.after(text2); else next_sibling.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(next_sibling);
  return next_sibling;
}

function clear_text_content(node) {
  node.textContent = "";
}

function should_defer_append() {
  if (!async_mode_flag) return false;
  if (null !== eager_block_effects) return false; else return 0 !== (active_effect.f & EFFECT_RAN);
}

var adjustments = new WeakMap;

function handle_error(error) {
  var effect2 = active_effect;
  if (null === effect2) {
    active_reaction.f |= ERROR_VALUE;
    return error;
  }
  if (dev_fallback_default && error instanceof Error && !adjustments.has(error)) adjustments.set(error, get_adjustments(error, effect2));
  if (0 === (effect2.f & EFFECT_RAN)) {
    if (0 === (effect2.f & BOUNDARY_EFFECT)) {
      if (dev_fallback_default && !effect2.parent && error instanceof Error) apply_adjustments(error);
      throw error;
    }
    effect2.b.error(error);
  } else invoke_error_boundary(error, effect2);
}

function invoke_error_boundary(error, effect2) {
  for (;null !== effect2; ) {
    if (0 !== (effect2.f & BOUNDARY_EFFECT)) try {
      effect2.b.error(error);
      return;
    } catch (e) {
      error = e;
    }
    effect2 = effect2.parent;
  }
  if (dev_fallback_default && error instanceof Error) apply_adjustments(error);
  throw error;
}

function get_adjustments(error, effect2) {
  var _a3, _b3, _c2;
  const message_descriptor = get_descriptor(error, "message");
  if (!message_descriptor || message_descriptor.configurable) {
    for (var indent = is_firefox ? "  " : "\t", component_stack = `\n${indent}in ${(null == (_a3 = effect2.fn) ? void 0 : _a3.name) || "<unknown>"}`, context = effect2.ctx; null !== context; ) {
      component_stack += `\n${indent}in ${null == (_b3 = context.function) ? void 0 : _b3[FILENAME].split("/").pop()}`;
      context = context.p;
    }
    return {
      message: error.message + `\n${component_stack}\n`,
      stack: null == (_c2 = error.stack) ? void 0 : _c2.split("\n").filter(line => !line.includes("svelte/src/internal")).join("\n")
    };
  }
}

function apply_adjustments(error) {
  const adjusted = adjustments.get(error);
  if (adjusted) {
    define_property(error, "message", {
      value: adjusted.message
    });
    define_property(error, "stack", {
      value: adjusted.stack
    });
  }
}

var _commit_callbacks, _discard_callbacks, _pending, _blocking_pending, _deferred, _dirty_effects, _maybe_dirty_effects, _Batch_instances, traverse_effect_tree_fn, defer_effects_fn, clear_marked_fn, resolve_fn, commit_fn, batches = new Set, current_batch = null, previous_batch = null, batch_values = null, queued_root_effects = [], last_scheduled_effect = null, is_flushing = false, is_flushing_sync = false, _Batch = class _Batch {
  constructor() {
    __privateAdd(this, _Batch_instances);
    __publicField(this, "committed", false);
    __publicField(this, "current", new Map);
    __publicField(this, "previous", new Map);
    __privateAdd(this, _commit_callbacks, new Set);
    __privateAdd(this, _discard_callbacks, new Set);
    __privateAdd(this, _pending, 0);
    __privateAdd(this, _blocking_pending, 0);
    __privateAdd(this, _deferred, null);
    __privateAdd(this, _dirty_effects, []);
    __privateAdd(this, _maybe_dirty_effects, []);
    __publicField(this, "skipped_effects", new Set);
    __publicField(this, "is_fork", false);
  }
  is_deferred() {
    return this.is_fork || __privateGet(this, _blocking_pending) > 0;
  }
  process(root_effects) {
    var _a3;
    queued_root_effects = [];
    previous_batch = null;
    this.apply();
    var target = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const root6 of root_effects) __privateMethod(this, _Batch_instances, traverse_effect_tree_fn).call(this, root6, target);
    if (!this.is_fork) __privateMethod(this, _Batch_instances, resolve_fn).call(this);
    if (this.is_deferred()) {
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, target.effects);
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, target.render_effects);
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, target.block_effects);
    } else {
      previous_batch = this;
      current_batch = null;
      flush_queued_effects(target.render_effects);
      flush_queued_effects(target.effects);
      previous_batch = null;
      null == (_a3 = __privateGet(this, _deferred)) || _a3.resolve();
    }
    batch_values = null;
  }
  capture(source2, value) {
    if (!this.previous.has(source2)) this.previous.set(source2, value);
    if (0 === (source2.f & ERROR_VALUE)) {
      this.current.set(source2, source2.v);
      null == batch_values || batch_values.set(source2, source2.v);
    }
  }
  activate() {
    current_batch = this;
    this.apply();
  }
  deactivate() {
    if (current_batch === this) {
      current_batch = null;
      batch_values = null;
    }
  }
  flush() {
    this.activate();
    if (queued_root_effects.length > 0) {
      flush_effects();
      if (null !== current_batch && current_batch !== this) return;
    } else if (0 === __privateGet(this, _pending)) this.process([]);
    this.deactivate();
  }
  discard() {
    for (const fn of __privateGet(this, _discard_callbacks)) fn(this);
    __privateGet(this, _discard_callbacks).clear();
  }
  increment(blocking) {
    __privateSet(this, _pending, __privateGet(this, _pending) + 1);
    if (blocking) __privateSet(this, _blocking_pending, __privateGet(this, _blocking_pending) + 1);
  }
  decrement(blocking) {
    __privateSet(this, _pending, __privateGet(this, _pending) - 1);
    if (blocking) __privateSet(this, _blocking_pending, __privateGet(this, _blocking_pending) - 1);
    this.revive();
  }
  revive() {
    for (const e of __privateGet(this, _dirty_effects)) {
      set_signal_status(e, DIRTY);
      schedule_effect(e);
    }
    for (const e of __privateGet(this, _maybe_dirty_effects)) {
      set_signal_status(e, MAYBE_DIRTY);
      schedule_effect(e);
    }
    __privateSet(this, _dirty_effects, []);
    __privateSet(this, _maybe_dirty_effects, []);
    this.flush();
  }
  oncommit(fn) {
    __privateGet(this, _commit_callbacks).add(fn);
  }
  ondiscard(fn) {
    __privateGet(this, _discard_callbacks).add(fn);
  }
  settled() {
    var _a3;
    return (null != (_a3 = __privateGet(this, _deferred)) ? _a3 : __privateSet(this, _deferred, deferred())).promise;
  }
  static ensure() {
    if (null === current_batch) {
      const batch = current_batch = new _Batch;
      batches.add(current_batch);
      if (!is_flushing_sync) _Batch.enqueue(() => {
        if (current_batch === batch) batch.flush();
      });
    }
    return current_batch;
  }
  static enqueue(task) {
    queue_micro_task(task);
  }
  apply() {
    if (async_mode_flag && (this.is_fork || 1 !== batches.size)) {
      batch_values = new Map(this.current);
      for (const batch of batches) if (batch !== this) for (const [source2, previous] of batch.previous) if (!batch_values.has(source2)) batch_values.set(source2, previous);
    }
  }
};

_commit_callbacks = new WeakMap;

_discard_callbacks = new WeakMap;

_pending = new WeakMap;

_blocking_pending = new WeakMap;

_deferred = new WeakMap;

_dirty_effects = new WeakMap;

_maybe_dirty_effects = new WeakMap;

_Batch_instances = new WeakSet;

traverse_effect_tree_fn = function(root6, target) {
  var _a3;
  root6.f ^= CLEAN;
  for (var effect2 = root6.first; null !== effect2; ) {
    var flags2 = effect2.f, is_branch = 0 !== (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)), skip = is_branch && 0 !== (flags2 & CLEAN) || 0 !== (flags2 & INERT) || this.skipped_effects.has(effect2);
    if (0 !== (effect2.f & BOUNDARY_EFFECT) && (null == (_a3 = effect2.b) ? void 0 : _a3.is_pending())) target = {
      parent: target,
      effect: effect2,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    if (!skip && null !== effect2.fn) {
      if (is_branch) effect2.f ^= CLEAN; else if (0 !== (flags2 & EFFECT)) target.effects.push(effect2); else if (async_mode_flag && 0 !== (flags2 & (RENDER_EFFECT | MANAGED_EFFECT))) target.render_effects.push(effect2); else if (is_dirty(effect2)) {
        if (0 !== (effect2.f & BLOCK_EFFECT)) target.block_effects.push(effect2);
        update_effect(effect2);
      }
      var child2 = effect2.first;
      if (null !== child2) {
        effect2 = child2;
        continue;
      }
    }
    var parent = effect2.parent;
    effect2 = effect2.next;
    for (;null === effect2 && null !== parent; ) {
      if (parent === target.effect) {
        __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, target.effects);
        __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, target.render_effects);
        __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, target.block_effects);
        target = target.parent;
      }
      effect2 = parent.next;
      parent = parent.parent;
    }
  }
};

defer_effects_fn = function(effects) {
  for (const e of effects) {
    (0 !== (e.f & DIRTY) ? __privateGet(this, _dirty_effects) : __privateGet(this, _maybe_dirty_effects)).push(e);
    __privateMethod(this, _Batch_instances, clear_marked_fn).call(this, e.deps);
    set_signal_status(e, CLEAN);
  }
};

clear_marked_fn = function(deps) {
  if (null !== deps) for (const dep of deps) if (0 !== (dep.f & DERIVED) && 0 !== (dep.f & WAS_MARKED)) {
    dep.f ^= WAS_MARKED;
    __privateMethod(this, _Batch_instances, clear_marked_fn).call(this, dep.deps);
  }
};

resolve_fn = function() {
  if (0 === __privateGet(this, _blocking_pending)) {
    for (const fn of __privateGet(this, _commit_callbacks)) fn();
    __privateGet(this, _commit_callbacks).clear();
  }
  if (0 === __privateGet(this, _pending)) __privateMethod(this, _Batch_instances, commit_fn).call(this);
};

commit_fn = function() {
  var _a3;
  if (batches.size > 1) {
    this.previous.clear();
    var previous_batch_values = batch_values, is_earlier = true, dummy_target = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const batch of batches) {
      if (batch === this) {
        is_earlier = false;
        continue;
      }
      const sources = [];
      for (const [source2, value] of this.current) {
        if (batch.current.has(source2)) if (is_earlier && value !== batch.current.get(source2)) batch.current.set(source2, value); else continue;
        sources.push(source2);
      }
      if (0 === sources.length) continue;
      const others = [ ...batch.current.keys() ].filter(s => !this.current.has(s));
      if (others.length > 0) {
        var prev_queued_root_effects = queued_root_effects;
        queued_root_effects = [];
        const marked = new Set, checked = new Map;
        for (const source2 of sources) mark_effects(source2, others, marked, checked);
        if (queued_root_effects.length > 0) {
          current_batch = batch;
          batch.apply();
          for (const root6 of queued_root_effects) __privateMethod(_a3 = batch, _Batch_instances, traverse_effect_tree_fn).call(_a3, root6, dummy_target);
          batch.deactivate();
        }
        queued_root_effects = prev_queued_root_effects;
      }
    }
    current_batch = null;
    batch_values = previous_batch_values;
  }
  this.committed = true;
  batches.delete(this);
};

var Batch = _Batch;

function flushSync(fn) {
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn) {
      if (null !== current_batch) flush_effects();
      result = fn();
    }
    for (;;) {
      flush_tasks();
      if (0 === queued_root_effects.length) {
        null == current_batch || current_batch.flush();
        if (0 === queued_root_effects.length) {
          last_scheduled_effect = null;
          return result;
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}

function flush_effects() {
  var _a3, was_updating_effect = is_updating_effect;
  is_flushing = true;
  var source_stacks = dev_fallback_default ? new Set : null;
  try {
    var flush_count = 0;
    set_is_updating_effect(true);
    for (;queued_root_effects.length > 0; ) {
      var batch = Batch.ensure();
      if (flush_count++ > 1e3) {
        if (dev_fallback_default) {
          var updates = new Map;
          for (const source2 of batch.current.keys()) for (const [stack2, update2] of null != (_a3 = source2.updated) ? _a3 : []) {
            var entry = updates.get(stack2);
            if (!entry) {
              entry = {
                error: update2.error,
                count: 0
              };
              updates.set(stack2, entry);
            }
            entry.count += update2.count;
          }
          for (const update2 of updates.values()) if (update2.error) console.error(update2.error);
        }
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
      if (dev_fallback_default) for (const source2 of batch.current.keys()) source_stacks.add(source2);
    }
  } finally {
    is_flushing = false;
    set_is_updating_effect(was_updating_effect);
    last_scheduled_effect = null;
    if (dev_fallback_default) for (const source2 of source_stacks) source2.updated = null;
  }
}

function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error) {
    if (dev_fallback_default) define_property(error, "stack", {
      value: ""
    });
    invoke_error_boundary(error, last_scheduled_effect);
  }
}

var eager_block_effects = null;

function flush_queued_effects(effects) {
  var length = effects.length;
  if (0 !== length) {
    for (var i = 0; i < length; ) {
      var effect2 = effects[i++];
      if (0 === (effect2.f & (DESTROYED | INERT)) && is_dirty(effect2)) {
        eager_block_effects = new Set;
        update_effect(effect2);
        if (null === effect2.deps && null === effect2.first && null === effect2.nodes) if (null === effect2.teardown && null === effect2.ac) unlink_effect(effect2); else effect2.fn = null;
        if ((null == eager_block_effects ? void 0 : eager_block_effects.size) > 0) {
          old_values.clear();
          for (const e of eager_block_effects) {
            if (0 !== (e.f & (DESTROYED | INERT))) continue;
            const ordered_effects = [ e ];
            let ancestor = e.parent;
            for (;null !== ancestor; ) {
              if (eager_block_effects.has(ancestor)) {
                eager_block_effects.delete(ancestor);
                ordered_effects.push(ancestor);
              }
              ancestor = ancestor.parent;
            }
            for (let j = ordered_effects.length - 1; j >= 0; j--) {
              const e2 = ordered_effects[j];
              if (0 === (e2.f & (DESTROYED | INERT))) update_effect(e2);
            }
          }
          eager_block_effects.clear();
        }
      }
    }
    eager_block_effects = null;
  }
}

function mark_effects(value, sources, marked, checked) {
  if (!marked.has(value)) {
    marked.add(value);
    if (null !== value.reactions) for (const reaction of value.reactions) {
      const flags2 = reaction.f;
      if (0 !== (flags2 & DERIVED)) mark_effects(reaction, sources, marked, checked); else if (0 !== (flags2 & (ASYNC | BLOCK_EFFECT)) && 0 === (flags2 & DIRTY) && depends_on(reaction, sources, checked)) {
        set_signal_status(reaction, DIRTY);
        schedule_effect(reaction);
      }
    }
  }
}

function depends_on(reaction, sources, checked) {
  const depends = checked.get(reaction);
  if (void 0 !== depends) return depends;
  if (null !== reaction.deps) for (const dep of reaction.deps) {
    if (sources.includes(dep)) return true;
    if (0 !== (dep.f & DERIVED) && depends_on(dep, sources, checked)) {
      checked.set(dep, true);
      return true;
    }
  }
  checked.set(reaction, false);
  return false;
}

function schedule_effect(signal) {
  for (var effect2 = last_scheduled_effect = signal; null !== effect2.parent; ) {
    var flags2 = (effect2 = effect2.parent).f;
    if (is_flushing && effect2 === active_effect && 0 !== (flags2 & BLOCK_EFFECT) && 0 === (flags2 & HEAD_EFFECT)) return;
    if (0 !== (flags2 & (ROOT_EFFECT | BRANCH_EFFECT))) {
      if (0 === (flags2 & CLEAN)) return;
      effect2.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect2);
}

function createSubscriber(start) {
  let stop, subscribers = 0, version = source(0);
  if (dev_fallback_default) tag(version, "createSubscriber version");
  return () => {
    if (effect_tracking()) {
      get(version);
      render_effect(() => {
        if (0 === subscribers) stop = untrack(() => start(() => increment(version)));
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (0 === subscribers) {
              null == stop || stop();
              stop = void 0;
              increment(version);
            }
          });
        };
      });
    }
  };
}

var _pending2, _anchor, _hydrate_open, _props, _children, _effect, _main_effect, _pending_effect, _failed_effect, _offscreen_fragment, _pending_anchor, _local_pending_count, _pending_count, _is_creating_fallback, _effect_pending, _effect_pending_subscriber, _Boundary_instances, hydrate_resolved_content_fn, hydrate_pending_content_fn, get_anchor_fn, run_fn, show_pending_snippet_fn, update_pending_count_fn, flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;

function boundary(node, props, children) {
  new Boundary(node, props, children);
}

var Boundary = class {
  constructor(node, props, children) {
    __privateAdd(this, _Boundary_instances);
    __publicField(this, "parent");
    __privateAdd(this, _pending2, false);
    __privateAdd(this, _anchor);
    __privateAdd(this, _hydrate_open, hydrating ? hydrate_node : null);
    __privateAdd(this, _props);
    __privateAdd(this, _children);
    __privateAdd(this, _effect);
    __privateAdd(this, _main_effect, null);
    __privateAdd(this, _pending_effect, null);
    __privateAdd(this, _failed_effect, null);
    __privateAdd(this, _offscreen_fragment, null);
    __privateAdd(this, _pending_anchor, null);
    __privateAdd(this, _local_pending_count, 0);
    __privateAdd(this, _pending_count, 0);
    __privateAdd(this, _is_creating_fallback, false);
    __privateAdd(this, _effect_pending, null);
    __privateAdd(this, _effect_pending_subscriber, createSubscriber(() => {
      __privateSet(this, _effect_pending, source(__privateGet(this, _local_pending_count)));
      if (dev_fallback_default) tag(__privateGet(this, _effect_pending), "$effect.pending()");
      return () => {
        __privateSet(this, _effect_pending, null);
      };
    }));
    __privateSet(this, _anchor, node);
    __privateSet(this, _props, props);
    __privateSet(this, _children, children);
    this.parent = active_effect.b;
    __privateSet(this, _pending2, !!__privateGet(this, _props).pending);
    __privateSet(this, _effect, block(() => {
      active_effect.b = this;
      if (hydrating) {
        const comment2 = __privateGet(this, _hydrate_open);
        hydrate_next();
        if (comment2.nodeType === COMMENT_NODE && comment2.data === HYDRATION_START_ELSE) __privateMethod(this, _Boundary_instances, hydrate_pending_content_fn).call(this); else __privateMethod(this, _Boundary_instances, hydrate_resolved_content_fn).call(this);
      } else {
        var anchor = __privateMethod(this, _Boundary_instances, get_anchor_fn).call(this);
        try {
          __privateSet(this, _main_effect, branch(() => children(anchor)));
        } catch (error) {
          this.error(error);
        }
        if (__privateGet(this, _pending_count) > 0) __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this); else __privateSet(this, _pending2, false);
      }
      return () => {
        var _a3;
        null == (_a3 = __privateGet(this, _pending_anchor)) || _a3.remove();
      };
    }, flags));
    if (hydrating) __privateSet(this, _anchor, hydrate_node);
  }
  is_pending() {
    return __privateGet(this, _pending2) || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!__privateGet(this, _props).pending;
  }
  update_pending_count(d) {
    __privateMethod(this, _Boundary_instances, update_pending_count_fn).call(this, d);
    __privateSet(this, _local_pending_count, __privateGet(this, _local_pending_count) + d);
    if (__privateGet(this, _effect_pending)) internal_set(__privateGet(this, _effect_pending), __privateGet(this, _local_pending_count));
  }
  get_effect_pending() {
    __privateGet(this, _effect_pending_subscriber).call(this);
    return get(__privateGet(this, _effect_pending));
  }
  error(error) {
    var onerror = __privateGet(this, _props).onerror;
    let failed = __privateGet(this, _props).failed;
    if (__privateGet(this, _is_creating_fallback) || !onerror && !failed) throw error;
    if (__privateGet(this, _main_effect)) {
      destroy_effect(__privateGet(this, _main_effect));
      __privateSet(this, _main_effect, null);
    }
    if (__privateGet(this, _pending_effect)) {
      destroy_effect(__privateGet(this, _pending_effect));
      __privateSet(this, _pending_effect, null);
    }
    if (__privateGet(this, _failed_effect)) {
      destroy_effect(__privateGet(this, _failed_effect));
      __privateSet(this, _failed_effect, null);
    }
    if (hydrating) {
      set_hydrate_node(__privateGet(this, _hydrate_open));
      next();
      set_hydrate_node(skip_nodes());
    }
    var did_reset = false, calling_on_error = false;
    const reset2 = () => {
      if (!did_reset) {
        did_reset = true;
        if (calling_on_error) svelte_boundary_reset_onerror();
        Batch.ensure();
        __privateSet(this, _local_pending_count, 0);
        if (null !== __privateGet(this, _failed_effect)) pause_effect(__privateGet(this, _failed_effect), () => {
          __privateSet(this, _failed_effect, null);
        });
        __privateSet(this, _pending2, this.has_pending_snippet());
        __privateSet(this, _main_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
          __privateSet(this, _is_creating_fallback, false);
          return branch(() => __privateGet(this, _children).call(this, __privateGet(this, _anchor)));
        }));
        if (__privateGet(this, _pending_count) > 0) __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this); else __privateSet(this, _pending2, false);
      } else svelte_boundary_reset_noop();
    };
    var previous_reaction = active_reaction;
    try {
      set_active_reaction(null);
      calling_on_error = true;
      null == onerror || onerror(error, reset2);
      calling_on_error = false;
    } catch (error2) {
      invoke_error_boundary(error2, __privateGet(this, _effect) && __privateGet(this, _effect).parent);
    } finally {
      set_active_reaction(previous_reaction);
    }
    if (failed) queue_micro_task(() => {
      __privateSet(this, _failed_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
        Batch.ensure();
        __privateSet(this, _is_creating_fallback, true);
        try {
          return branch(() => {
            failed(__privateGet(this, _anchor), () => error, () => reset2);
          });
        } catch (error2) {
          invoke_error_boundary(error2, __privateGet(this, _effect).parent);
          return null;
        } finally {
          __privateSet(this, _is_creating_fallback, false);
        }
      }));
    });
  }
};

_pending2 = new WeakMap;

_anchor = new WeakMap;

_hydrate_open = new WeakMap;

_props = new WeakMap;

_children = new WeakMap;

_effect = new WeakMap;

_main_effect = new WeakMap;

_pending_effect = new WeakMap;

_failed_effect = new WeakMap;

_offscreen_fragment = new WeakMap;

_pending_anchor = new WeakMap;

_local_pending_count = new WeakMap;

_pending_count = new WeakMap;

_is_creating_fallback = new WeakMap;

_effect_pending = new WeakMap;

_effect_pending_subscriber = new WeakMap;

_Boundary_instances = new WeakSet;

hydrate_resolved_content_fn = function() {
  try {
    __privateSet(this, _main_effect, branch(() => __privateGet(this, _children).call(this, __privateGet(this, _anchor))));
  } catch (error) {
    this.error(error);
  }
  __privateSet(this, _pending2, false);
};

hydrate_pending_content_fn = function() {
  const pending2 = __privateGet(this, _props).pending;
  if (pending2) {
    __privateSet(this, _pending_effect, branch(() => pending2(__privateGet(this, _anchor))));
    Batch.enqueue(() => {
      var anchor = __privateMethod(this, _Boundary_instances, get_anchor_fn).call(this);
      __privateSet(this, _main_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
        Batch.ensure();
        return branch(() => __privateGet(this, _children).call(this, anchor));
      }));
      if (__privateGet(this, _pending_count) > 0) __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this); else {
        pause_effect(__privateGet(this, _pending_effect), () => {
          __privateSet(this, _pending_effect, null);
        });
        __privateSet(this, _pending2, false);
      }
    });
  }
};

get_anchor_fn = function() {
  var anchor = __privateGet(this, _anchor);
  if (__privateGet(this, _pending2)) {
    __privateSet(this, _pending_anchor, create_text());
    __privateGet(this, _anchor).before(__privateGet(this, _pending_anchor));
    anchor = __privateGet(this, _pending_anchor);
  }
  return anchor;
};

run_fn = function(fn) {
  var previous_effect = active_effect, previous_reaction = active_reaction, previous_ctx = component_context;
  set_active_effect(__privateGet(this, _effect));
  set_active_reaction(__privateGet(this, _effect));
  set_component_context(__privateGet(this, _effect).ctx);
  try {
    return fn();
  } catch (e) {
    handle_error(e);
    return null;
  } finally {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_ctx);
  }
};

show_pending_snippet_fn = function() {
  const pending2 = __privateGet(this, _props).pending;
  if (null !== __privateGet(this, _main_effect)) {
    __privateSet(this, _offscreen_fragment, document.createDocumentFragment());
    __privateGet(this, _offscreen_fragment).append(__privateGet(this, _pending_anchor));
    move_effect(__privateGet(this, _main_effect), __privateGet(this, _offscreen_fragment));
  }
  if (null === __privateGet(this, _pending_effect)) __privateSet(this, _pending_effect, branch(() => pending2(__privateGet(this, _anchor))));
};

update_pending_count_fn = function(d) {
  var _a3;
  if (this.has_pending_snippet()) {
    __privateSet(this, _pending_count, __privateGet(this, _pending_count) + d);
    if (0 === __privateGet(this, _pending_count)) {
      __privateSet(this, _pending2, false);
      if (__privateGet(this, _pending_effect)) pause_effect(__privateGet(this, _pending_effect), () => {
        __privateSet(this, _pending_effect, null);
      });
      if (__privateGet(this, _offscreen_fragment)) {
        __privateGet(this, _anchor).before(__privateGet(this, _offscreen_fragment));
        __privateSet(this, _offscreen_fragment, null);
      }
    }
  } else if (this.parent) __privateMethod(_a3 = this.parent, _Boundary_instances, update_pending_count_fn).call(_a3, d);
};

function flatten(blockers, sync, async2, fn) {
  const d = is_runes() ? derived : derived_safe_equal;
  if (0 !== async2.length || 0 !== blockers.length) {
    var batch = current_batch, parent = active_effect, restore = capture();
    if (blockers.length > 0) Promise.all(blockers).then(() => {
      restore();
      try {
        return run3();
      } finally {
        null == batch || batch.deactivate();
        unset_context();
      }
    }); else run3();
  } else fn(sync.map(d));
  function run3() {
    Promise.all(async2.map(expression => async_derived(expression))).then(result => {
      restore();
      try {
        fn([ ...sync.map(d), ...result ]);
      } catch (error) {
        if (0 === (parent.f & DESTROYED)) invoke_error_boundary(error, parent);
      }
      null == batch || batch.deactivate();
      unset_context();
    }).catch(error => {
      invoke_error_boundary(error, parent);
    });
  }
}

function capture() {
  var previous_effect = active_effect, previous_reaction = active_reaction, previous_component_context = component_context, previous_batch2 = current_batch;
  if (dev_fallback_default) var previous_dev_stack = dev_stack;
  return function restore(activate_batch = true) {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_component_context);
    if (activate_batch) null == previous_batch2 || previous_batch2.activate();
    if (dev_fallback_default) {
      set_from_async_derived(null);
      set_dev_stack(previous_dev_stack);
    }
  };
}

function unset_context() {
  set_active_effect(null);
  set_active_reaction(null);
  set_component_context(null);
  if (dev_fallback_default) {
    set_from_async_derived(null);
    set_dev_stack(null);
  }
}

var current_async_effect = null;

function set_from_async_derived(v) {
  current_async_effect = v;
}

var recent_async_deriveds = new Set;

function derived(fn) {
  var flags2 = DERIVED | DIRTY, parent_derived = null !== active_reaction && 0 !== (active_reaction.f & DERIVED) ? active_reaction : null;
  if (null !== active_effect) active_effect.f |= EFFECT_PRESERVED;
  const signal = {
    ctx: component_context,
    deps: null,
    effects: null,
    equals,
    f: flags2,
    fn,
    reactions: null,
    rv: 0,
    v: UNINITIALIZED,
    wv: 0,
    parent: null != parent_derived ? parent_derived : active_effect,
    ac: null
  };
  if (dev_fallback_default && tracing_mode_flag) signal.created = get_error("created at");
  return signal;
}

function async_derived(fn, location) {
  let parent = active_effect;
  if (null === parent) async_derived_orphan();
  var boundary2 = parent.b, promise = void 0, signal = source(UNINITIALIZED), should_suspend = !active_reaction, deferreds = new Map;
  async_effect(() => {
    var _a3;
    if (dev_fallback_default) current_async_effect = active_effect;
    var d = deferred();
    promise = d.promise;
    try {
      Promise.resolve(fn()).then(d.resolve, d.reject).then(() => {
        if (batch === current_batch && batch.committed) batch.deactivate();
        unset_context();
      });
    } catch (error) {
      d.reject(error);
      unset_context();
    }
    if (dev_fallback_default) current_async_effect = null;
    var batch = current_batch;
    if (should_suspend) {
      var blocking = !boundary2.is_pending();
      boundary2.update_pending_count(1);
      batch.increment(blocking);
      null == (_a3 = deferreds.get(batch)) || _a3.reject(STALE_REACTION);
      deferreds.delete(batch);
      deferreds.set(batch, d);
    }
    const handler = (value, error = void 0) => {
      current_async_effect = null;
      batch.activate();
      if (error) {
        if (error !== STALE_REACTION) {
          signal.f |= ERROR_VALUE;
          internal_set(signal, error);
        }
      } else {
        if (0 !== (signal.f & ERROR_VALUE)) signal.f ^= ERROR_VALUE;
        internal_set(signal, value);
        for (const [b, d2] of deferreds) {
          deferreds.delete(b);
          if (b === batch) break;
          d2.reject(STALE_REACTION);
        }
        if (dev_fallback_default && void 0 !== location) {
          recent_async_deriveds.add(signal);
          setTimeout(() => {
            if (recent_async_deriveds.has(signal)) {
              await_waterfall(signal.label, location);
              recent_async_deriveds.delete(signal);
            }
          });
        }
      }
      if (should_suspend) {
        boundary2.update_pending_count(-1);
        batch.decrement(blocking);
      }
    };
    d.promise.then(handler, e => handler(null, e || "unknown"));
  });
  teardown(() => {
    for (const d of deferreds.values()) d.reject(STALE_REACTION);
  });
  if (dev_fallback_default) signal.f |= ASYNC;
  return new Promise(fulfil => {
    (function next2(p) {
      function go() {
        if (p === promise) fulfil(signal); else next2(promise);
      }
      p.then(go, go);
    })(promise);
  });
}

function user_derived(fn) {
  const d = derived(fn);
  if (!async_mode_flag) push_reaction_value(d);
  return d;
}

function derived_safe_equal(fn) {
  const signal = derived(fn);
  signal.equals = safe_equals;
  return signal;
}

function destroy_derived_effects(derived3) {
  var effects = derived3.effects;
  if (null !== effects) {
    derived3.effects = null;
    for (var i = 0; i < effects.length; i += 1) destroy_effect(effects[i]);
  }
}

var stack = [];

function get_derived_parent_effect(derived3) {
  for (var parent = derived3.parent; null !== parent; ) {
    if (0 === (parent.f & DERIVED)) return 0 === (parent.f & DESTROYED) ? parent : null;
    parent = parent.parent;
  }
  return null;
}

function execute_derived(derived3) {
  var value, prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived3));
  if (dev_fallback_default) {
    let prev_eager_effects = eager_effects;
    set_eager_effects(new Set);
    try {
      if (stack.includes(derived3)) derived_references_self();
      stack.push(derived3);
      derived3.f &= ~WAS_MARKED;
      destroy_derived_effects(derived3);
      value = update_reaction(derived3);
    } finally {
      set_active_effect(prev_active_effect);
      set_eager_effects(prev_eager_effects);
      stack.pop();
    }
  } else try {
    derived3.f &= ~WAS_MARKED;
    destroy_derived_effects(derived3);
    value = update_reaction(derived3);
  } finally {
    set_active_effect(prev_active_effect);
  }
  return value;
}

function update_derived(derived3) {
  var _a3, _b3, value = execute_derived(derived3);
  if (!derived3.equals(value)) {
    if (!(null == (_a3 = current_batch) ? void 0 : _a3.is_fork)) derived3.v = value;
    derived3.wv = increment_write_version();
  }
  if (!is_destroying_effect) if (null !== batch_values) {
    if (effect_tracking() || (null == (_b3 = current_batch) ? void 0 : _b3.is_fork)) batch_values.set(derived3, value);
  } else set_signal_status(derived3, 0 === (derived3.f & CONNECTED) ? MAYBE_DIRTY : CLEAN);
}

var eager_effects = new Set, old_values = new Map;

function set_eager_effects(v) {
  eager_effects = v;
}

var eager_effects_deferred = false;

function set_eager_effects_deferred() {
  eager_effects_deferred = true;
}

function source(v, stack2) {
  var signal = {
    f: 0,
    v,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  if (dev_fallback_default && tracing_mode_flag) {
    signal.created = null != stack2 ? stack2 : get_error("created at");
    signal.updated = null;
    signal.set_during_effect = false;
    signal.trace = null;
  }
  return signal;
}

function state(v, stack2) {
  const s = source(v, stack2);
  push_reaction_value(s);
  return s;
}

function mutable_source(initial_value, immutable = false, trackable = true) {
  var _a3, _b3;
  const s = source(initial_value);
  if (!immutable) s.equals = safe_equals;
  if (legacy_mode_flag && trackable && null !== component_context && null !== component_context.l) (null != (_b3 = (_a3 = component_context.l).s) ? _b3 : _a3.s = []).push(s);
  return s;
}

function set(source2, value, should_proxy = false) {
  var _a3;
  if (null !== active_reaction && (!untracking || 0 !== (active_reaction.f & EAGER_EFFECT)) && is_runes() && 0 !== (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | EAGER_EFFECT)) && !(null == (_a3 = current_sources) ? void 0 : _a3.includes(source2))) state_unsafe_mutation();
  let new_value = should_proxy ? proxy(value) : value;
  if (dev_fallback_default) tag_proxy(new_value, source2.label);
  return internal_set(source2, new_value);
}

function internal_set(source2, value) {
  var _b3, _c2;
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) old_values.set(source2, value); else old_values.set(source2, old_value);
    source2.v = value;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if (dev_fallback_default) {
      if (tracing_mode_flag || null !== active_effect) {
        null != source2.updated || (source2.updated = new Map);
        const count = (null != (_c2 = null == (_b3 = source2.updated.get("")) ? void 0 : _b3.count) ? _c2 : 0) + 1;
        source2.updated.set("", {
          error: null,
          count
        });
        if (tracing_mode_flag || count > 5) {
          const error = get_error("updated at");
          if (null !== error) {
            let entry = source2.updated.get(error.stack);
            if (!entry) {
              entry = {
                error,
                count: 0
              };
              source2.updated.set(error.stack, entry);
            }
            entry.count++;
          }
        }
      }
      if (null !== active_effect) source2.set_during_effect = true;
    }
    if (0 !== (source2.f & DERIVED)) {
      if (0 !== (source2.f & DIRTY)) execute_derived(source2);
      set_signal_status(source2, 0 !== (source2.f & CONNECTED) ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (is_runes() && null !== active_effect && 0 !== (active_effect.f & CLEAN) && 0 === (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT))) if (null === untracked_writes) set_untracked_writes([ source2 ]); else untracked_writes.push(source2);
    if (!batch.is_fork && eager_effects.size > 0 && !eager_effects_deferred) flush_eager_effects();
  }
  return value;
}

function flush_eager_effects() {
  eager_effects_deferred = false;
  var prev_is_updating_effect = is_updating_effect;
  set_is_updating_effect(true);
  const inspects = Array.from(eager_effects);
  try {
    for (const effect2 of inspects) {
      if (0 !== (effect2.f & CLEAN)) set_signal_status(effect2, MAYBE_DIRTY);
      if (is_dirty(effect2)) update_effect(effect2);
    }
  } finally {
    set_is_updating_effect(prev_is_updating_effect);
  }
  eager_effects.clear();
}

function increment(source2) {
  set(source2, source2.v + 1);
}

function mark_reactions(signal, status) {
  var _a3, reactions = signal.reactions;
  if (null !== reactions) for (var runes = is_runes(), length = reactions.length, i = 0; i < length; i++) {
    var reaction = reactions[i], flags2 = reaction.f;
    if (runes || reaction !== active_effect) if (!dev_fallback_default || 0 === (flags2 & EAGER_EFFECT)) {
      var not_dirty = 0 === (flags2 & DIRTY);
      if (not_dirty) set_signal_status(reaction, status);
      if (0 !== (flags2 & DERIVED)) {
        var derived3 = reaction;
        null == (_a3 = batch_values) || _a3.delete(derived3);
        if (0 === (flags2 & WAS_MARKED)) {
          if (flags2 & CONNECTED) reaction.f |= WAS_MARKED;
          mark_reactions(derived3, MAYBE_DIRTY);
        }
      } else if (not_dirty) {
        if (0 !== (flags2 & BLOCK_EFFECT) && null !== eager_block_effects) eager_block_effects.add(reaction);
        schedule_effect(reaction);
      }
    } else eager_effects.add(reaction);
  }
}

var captured_signals = null, listening_to_form_reset = false;

function add_form_reset_listener() {
  if (!listening_to_form_reset) {
    listening_to_form_reset = true;
    document.addEventListener("reset", evt => {
      Promise.resolve().then(() => {
        var _a3;
        if (!evt.defaultPrevented) for (const e of evt.target.elements) null == (_a3 = e.__on_r) || _a3.call(e);
      });
    }, {
      capture: true
    });
  }
}

function without_reactive_context(fn) {
  var previous_reaction = active_reaction, previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}

function listen_to_event_and_reset_event(element2, event2, handler, on_reset = handler) {
  element2.addEventListener(event2, () => without_reactive_context(handler));
  const prev = element2.__on_r;
  if (prev) element2.__on_r = () => {
    prev();
    on_reset(true);
  }; else element2.__on_r = () => on_reset(true);
  add_form_reset_listener();
}

var is_updating_effect = false;

function set_is_updating_effect(value) {
  is_updating_effect = value;
}

var is_destroying_effect = false;

function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}

var active_reaction = null, untracking = false;

function set_active_reaction(reaction) {
  active_reaction = reaction;
}

var active_effect = null;

function set_active_effect(effect2) {
  active_effect = effect2;
}

var current_sources = null;

function push_reaction_value(value) {
  if (null !== active_reaction && (!async_mode_flag || 0 !== (active_reaction.f & DERIVED))) if (null === current_sources) current_sources = [ value ]; else current_sources.push(value);
}

var new_deps = null, skipped_deps = 0, untracked_writes = null;

function set_untracked_writes(value) {
  untracked_writes = value;
}

var write_version = 1, read_version = 0, update_version = read_version;

function set_update_version(value) {
  update_version = value;
}

function increment_write_version() {
  return ++write_version;
}

function is_dirty(reaction) {
  var flags2 = reaction.f;
  if (0 !== (flags2 & DIRTY)) return true;
  if (flags2 & DERIVED) reaction.f &= ~WAS_MARKED;
  if (0 !== (flags2 & MAYBE_DIRTY)) {
    var dependencies = reaction.deps;
    if (null !== dependencies) for (var length = dependencies.length, i = 0; i < length; i++) {
      var dependency = dependencies[i];
      if (is_dirty(dependency)) update_derived(dependency);
      if (dependency.wv > reaction.wv) return true;
    }
    if (0 !== (flags2 & CONNECTED) && null === batch_values) set_signal_status(reaction, CLEAN);
  }
  return false;
}

function schedule_possible_effect_self_invalidation(signal, effect2, root6 = true) {
  var reactions = signal.reactions;
  if (null !== reactions) if (async_mode_flag || !(null == current_sources ? void 0 : current_sources.includes(signal))) for (var i = 0; i < reactions.length; i++) {
    var reaction = reactions[i];
    if (0 !== (reaction.f & DERIVED)) schedule_possible_effect_self_invalidation(reaction, effect2, false); else if (effect2 === reaction) {
      if (root6) set_signal_status(reaction, DIRTY); else if (0 !== (reaction.f & CLEAN)) set_signal_status(reaction, MAYBE_DIRTY);
      schedule_effect(reaction);
    }
  }
}

function update_reaction(reaction) {
  var _a3, _b3, previous_deps = new_deps, previous_skipped_deps = skipped_deps, previous_untracked_writes = untracked_writes, previous_reaction = active_reaction, previous_sources = current_sources, previous_component_context = component_context, previous_untracking = untracking, previous_update_version = update_version, flags2 = reaction.f;
  new_deps = null;
  skipped_deps = 0;
  untracked_writes = null;
  active_reaction = 0 === (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (null !== reaction.ac) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var result = (0, reaction.fn)(), deps = reaction.deps;
    if (null !== new_deps) {
      var i;
      remove_reactions(reaction, skipped_deps);
      if (null !== deps && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i = 0; i < new_deps.length; i++) deps[skipped_deps + i] = new_deps[i];
      } else reaction.deps = deps = new_deps;
      if (effect_tracking() && 0 !== (reaction.f & CONNECTED)) for (i = skipped_deps; i < deps.length; i++) (null != (_b3 = (_a3 = deps[i]).reactions) ? _b3 : _a3.reactions = []).push(reaction);
    } else if (null !== deps && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && null !== untracked_writes && !untracking && null !== deps && 0 === (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY))) for (i = 0; i < untracked_writes.length; i++) schedule_possible_effect_self_invalidation(untracked_writes[i], reaction);
    if (null !== previous_reaction && previous_reaction !== reaction) {
      read_version++;
      if (null !== untracked_writes) if (null === previous_untracked_writes) previous_untracked_writes = untracked_writes; else previous_untracked_writes.push(...untracked_writes);
    }
    if (0 !== (reaction.f & ERROR_VALUE)) reaction.f ^= ERROR_VALUE;
    return result;
  } catch (error) {
    return handle_error(error);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}

function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (null !== reactions) {
    var index2 = index_of.call(reactions, signal);
    if (-1 !== index2) {
      var new_length = reactions.length - 1;
      if (0 === new_length) reactions = dependency.reactions = null; else {
        reactions[index2] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (null === reactions && 0 !== (dependency.f & DERIVED) && (null === new_deps || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if (0 !== (dependency.f & CONNECTED)) {
      dependency.f ^= CONNECTED;
      dependency.f &= ~WAS_MARKED;
    }
    destroy_derived_effects(dependency);
    remove_reactions(dependency, 0);
  }
}

function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (null !== dependencies) for (var i = start_index; i < dependencies.length; i++) remove_reaction(signal, dependencies[i]);
}

function update_effect(effect2) {
  var _a3, flags2 = effect2.f;
  if (0 === (flags2 & DESTROYED)) {
    set_signal_status(effect2, CLEAN);
    var previous_effect = active_effect, was_updating_effect = is_updating_effect;
    active_effect = effect2;
    is_updating_effect = true;
    if (dev_fallback_default) {
      var previous_component_fn = dev_current_component_function;
      set_dev_current_component_function(effect2.component_function);
      var previous_stack = dev_stack;
      set_dev_stack(null != (_a3 = effect2.dev_stack) ? _a3 : dev_stack);
    }
    try {
      if (0 !== (flags2 & (BLOCK_EFFECT | MANAGED_EFFECT))) destroy_block_effect_children(effect2); else destroy_effect_children(effect2);
      execute_effect_teardown(effect2);
      var teardown2 = update_reaction(effect2);
      effect2.teardown = "function" == typeof teardown2 ? teardown2 : null;
      effect2.wv = write_version;
      if (dev_fallback_default && tracing_mode_flag && 0 !== (effect2.f & DIRTY) && null !== effect2.deps) for (var dep of effect2.deps) if (dep.set_during_effect) {
        dep.wv = increment_write_version();
        dep.set_during_effect = false;
      }
    } finally {
      is_updating_effect = was_updating_effect;
      active_effect = previous_effect;
      if (dev_fallback_default) {
        set_dev_current_component_function(previous_component_fn);
        set_dev_stack(previous_stack);
      }
    }
  }
}

async function tick() {
  if (async_mode_flag) return new Promise(f => {
    requestAnimationFrame(() => f());
    setTimeout(() => f());
  });
  await Promise.resolve();
  flushSync();
}

function get(signal) {
  var _a3, _b3, _c2, _d, _e, is_derived = 0 !== (signal.f & DERIVED);
  null == (_a3 = captured_signals) || _a3.add(signal);
  if (null !== active_reaction && !untracking) if (!(null !== active_effect && 0 !== (active_effect.f & DESTROYED) || (null == current_sources ? void 0 : current_sources.includes(signal)))) {
    var deps = active_reaction.deps;
    if (0 !== (active_reaction.f & REACTION_IS_UPDATING)) {
      if (signal.rv < read_version) {
        signal.rv = read_version;
        if (null === new_deps && null !== deps && deps[skipped_deps] === signal) skipped_deps++; else if (null === new_deps) new_deps = [ signal ]; else if (!new_deps.includes(signal)) new_deps.push(signal);
      }
    } else {
      (null != (_b3 = active_reaction.deps) ? _b3 : active_reaction.deps = []).push(signal);
      var reactions = signal.reactions;
      if (null === reactions) signal.reactions = [ active_reaction ]; else if (!reactions.includes(active_reaction)) reactions.push(active_reaction);
    }
  }
  if (dev_fallback_default) {
    recent_async_deriveds.delete(signal);
    if (tracing_mode_flag && !untracking && null !== tracing_expressions && null !== active_reaction && tracing_expressions.reaction === active_reaction) if (signal.trace) signal.trace(); else {
      var trace2 = get_error("traced at");
      if (trace2) {
        var entry = tracing_expressions.entries.get(signal);
        if (void 0 === entry) {
          entry = {
            traces: []
          };
          tracing_expressions.entries.set(signal, entry);
        }
        var last = entry.traces[entry.traces.length - 1];
        if (trace2.stack !== (null == last ? void 0 : last.stack)) entry.traces.push(trace2);
      }
    }
  }
  if (is_destroying_effect) {
    if (old_values.has(signal)) return old_values.get(signal);
    if (is_derived) {
      var derived3 = signal, value = derived3.v;
      if (0 === (derived3.f & CLEAN) && null !== derived3.reactions || depends_on_old_values(derived3)) value = execute_derived(derived3);
      old_values.set(derived3, value);
      return value;
    }
  } else if (is_derived && (!(null == (_c2 = batch_values) ? void 0 : _c2.has(signal)) || (null == (_d = current_batch) ? void 0 : _d.is_fork) && !effect_tracking())) {
    if (is_dirty(derived3 = signal)) update_derived(derived3);
    if (is_updating_effect && effect_tracking() && 0 === (derived3.f & CONNECTED)) reconnect(derived3);
  }
  if (null == (_e = batch_values) ? void 0 : _e.has(signal)) return batch_values.get(signal);
  if (0 !== (signal.f & ERROR_VALUE)) throw signal.v;
  return signal.v;
}

function reconnect(derived3) {
  var _a3;
  if (null !== derived3.deps) {
    derived3.f ^= CONNECTED;
    for (const dep of derived3.deps) {
      (null != (_a3 = dep.reactions) ? _a3 : dep.reactions = []).push(derived3);
      if (0 !== (dep.f & DERIVED) && 0 === (dep.f & CONNECTED)) reconnect(dep);
    }
  }
}

function depends_on_old_values(derived3) {
  if (derived3.v === UNINITIALIZED) return true;
  if (null === derived3.deps) return false;
  for (const dep of derived3.deps) {
    if (old_values.has(dep)) return true;
    if (0 !== (dep.f & DERIVED) && depends_on_old_values(dep)) return true;
  }
  return false;
}

function untrack(fn) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn();
  } finally {
    untracking = previous_untracking;
  }
}

var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);

function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}

function validate_effect(rune) {
  if (null === active_effect) {
    if (null === active_reaction) effect_orphan(rune);
    effect_in_unowned_derived();
  }
  if (is_destroying_effect) effect_in_teardown(rune);
}

function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (null === parent_last) parent_effect.last = parent_effect.first = effect2; else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}

function create_effect(type, fn, sync) {
  var _a3, parent = active_effect;
  if (dev_fallback_default) for (;null !== parent && 0 !== (parent.f & EAGER_EFFECT); ) parent = parent.parent;
  if (null !== parent && 0 !== (parent.f & INERT)) type |= INERT;
  var effect2 = {
    ctx: component_context,
    deps: null,
    nodes: null,
    f: type | DIRTY | CONNECTED,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    b: parent && parent.b,
    prev: null,
    teardown: null,
    wv: 0,
    ac: null
  };
  if (dev_fallback_default) effect2.component_function = dev_current_component_function;
  if (sync) try {
    update_effect(effect2);
    effect2.f |= EFFECT_RAN;
  } catch (e2) {
    destroy_effect(effect2);
    throw e2;
  } else if (null !== fn) schedule_effect(effect2);
  var e = effect2;
  if (sync && null === e.deps && null === e.teardown && null === e.nodes && e.first === e.last && 0 === (e.f & EFFECT_PRESERVED)) {
    e = e.first;
    if (0 !== (type & BLOCK_EFFECT) && 0 !== (type & EFFECT_TRANSPARENT) && null !== e) e.f |= EFFECT_TRANSPARENT;
  }
  if (null !== e) {
    e.parent = parent;
    if (null !== parent) push_effect(e, parent);
    if (null !== active_reaction && 0 !== (active_reaction.f & DERIVED) && 0 === (type & ROOT_EFFECT)) {
      var derived3 = active_reaction;
      (null != (_a3 = derived3.effects) ? _a3 : derived3.effects = []).push(e);
    }
  }
  return effect2;
}

function effect_tracking() {
  return null !== active_reaction && !untracking;
}

function teardown(fn) {
  const effect2 = create_effect(RENDER_EFFECT, null, false);
  set_signal_status(effect2, CLEAN);
  effect2.teardown = fn;
  return effect2;
}

function user_effect(fn) {
  var _a3;
  validate_effect("$effect");
  if (dev_fallback_default) define_property(fn, "name", {
    value: "$effect"
  });
  var flags2 = active_effect.f;
  if (!active_reaction && 0 !== (flags2 & BRANCH_EFFECT) && 0 === (flags2 & EFFECT_RAN)) {
    var context = component_context;
    (null != (_a3 = context.e) ? _a3 : context.e = []).push(fn);
  } else return create_user_effect(fn);
}

function create_user_effect(fn) {
  return create_effect(EFFECT | USER_EFFECT, fn, false);
}

function effect_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return () => {
    destroy_effect(effect2);
  };
}

function component_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return (options = {}) => new Promise(fulfil => {
    if (options.outro) pause_effect(effect2, () => {
      destroy_effect(effect2);
      fulfil(void 0);
    }); else {
      destroy_effect(effect2);
      fulfil(void 0);
    }
  });
}

function effect(fn) {
  return create_effect(EFFECT, fn, false);
}

function async_effect(fn) {
  return create_effect(ASYNC | EFFECT_PRESERVED, fn, true);
}

function render_effect(fn, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn, true);
}

function template_effect(fn, sync = [], async2 = [], blockers = []) {
  flatten(blockers, sync, async2, values => {
    create_effect(RENDER_EFFECT, () => fn(...values.map(get)), true);
  });
}

function block(fn, flags2 = 0) {
  var effect2 = create_effect(BLOCK_EFFECT | flags2, fn, true);
  if (dev_fallback_default) effect2.dev_stack = dev_stack;
  return effect2;
}

function branch(fn) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true);
}

function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (null !== teardown2) {
    const previously_destroying_effect = is_destroying_effect, previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}

function destroy_effect_children(signal, remove_dom = false) {
  var effect2 = signal.first;
  signal.first = signal.last = null;
  for (;null !== effect2; ) {
    const controller = effect2.ac;
    if (null !== controller) without_reactive_context(() => {
      controller.abort(STALE_REACTION);
    });
    var next2 = effect2.next;
    if (0 !== (effect2.f & ROOT_EFFECT)) effect2.parent = null; else destroy_effect(effect2, remove_dom);
    effect2 = next2;
  }
}

function destroy_block_effect_children(signal) {
  for (var effect2 = signal.first; null !== effect2; ) {
    var next2 = effect2.next;
    if (0 === (effect2.f & BRANCH_EFFECT)) destroy_effect(effect2);
    effect2 = next2;
  }
}

function destroy_effect(effect2, remove_dom = true) {
  var removed = false;
  if ((remove_dom || 0 !== (effect2.f & HEAD_EFFECT)) && null !== effect2.nodes && null !== effect2.nodes.end) {
    remove_effect_dom(effect2.nodes.start, effect2.nodes.end);
    removed = true;
  }
  destroy_effect_children(effect2, remove_dom && !removed);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  var transitions = effect2.nodes && effect2.nodes.t;
  if (null !== transitions) for (const transition2 of transitions) transition2.stop();
  execute_effect_teardown(effect2);
  var parent = effect2.parent;
  if (null !== parent && null !== parent.first) unlink_effect(effect2);
  if (dev_fallback_default) effect2.component_function = null;
  effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes = effect2.ac = null;
}

function remove_effect_dom(node, end) {
  for (;null !== node; ) {
    var next2 = node === end ? null : get_next_sibling(node);
    node.remove();
    node = next2;
  }
}

function unlink_effect(effect2) {
  var parent = effect2.parent, prev = effect2.prev, next2 = effect2.next;
  if (null !== prev) prev.next = next2;
  if (null !== next2) next2.prev = prev;
  if (null !== parent) {
    if (parent.first === effect2) parent.first = next2;
    if (parent.last === effect2) parent.last = prev;
  }
}

function pause_effect(effect2, callback, destroy = true) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  var fn = () => {
    if (destroy) destroy_effect(effect2);
    if (callback) callback();
  }, remaining = transitions.length;
  if (remaining > 0) {
    var check = () => --remaining || fn();
    for (var transition2 of transitions) transition2.out(check);
  } else fn();
}

function pause_children(effect2, transitions, local) {
  if (0 === (effect2.f & INERT)) {
    effect2.f ^= INERT;
    var t = effect2.nodes && effect2.nodes.t;
    if (null !== t) for (const transition2 of t) if (transition2.is_global || local) transitions.push(transition2);
    for (var child2 = effect2.first; null !== child2; ) {
      var sibling2 = child2.next;
      pause_children(child2, transitions, 0 !== (child2.f & EFFECT_TRANSPARENT) || 0 !== (child2.f & BRANCH_EFFECT) && 0 !== (effect2.f & BLOCK_EFFECT) ? local : false);
      child2 = sibling2;
    }
  }
}

function resume_effect(effect2) {
  resume_children(effect2, true);
}

function resume_children(effect2, local) {
  if (0 !== (effect2.f & INERT)) {
    effect2.f ^= INERT;
    if (0 === (effect2.f & CLEAN)) {
      set_signal_status(effect2, DIRTY);
      schedule_effect(effect2);
    }
    for (var child2 = effect2.first; null !== child2; ) {
      var sibling2 = child2.next;
      resume_children(child2, 0 !== (child2.f & EFFECT_TRANSPARENT) || 0 !== (child2.f & BRANCH_EFFECT) ? local : false);
      child2 = sibling2;
    }
    var t = effect2.nodes && effect2.nodes.t;
    if (null !== t) for (const transition2 of t) if (transition2.is_global || local) transition2.in();
  }
}

function move_effect(effect2, fragment) {
  if (effect2.nodes) for (var node = effect2.nodes.start, end = effect2.nodes.end; null !== node; ) {
    var next2 = node === end ? null : get_next_sibling(node);
    fragment.append(node);
    node = next2;
  }
}

var regex_return_characters = /\r/g;

function hash(str) {
  let hash2 = 5381, i = (str = str.replace(regex_return_characters, "")).length;
  for (;i--; ) hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return (hash2 >>> 0).toString(36);
}

var DOM_BOOLEAN_ATTRIBUTES = [ "allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "indeterminate", "inert", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected", "webkitdirectory", "defer", "disablepictureinpicture", "disableremoteplayback" ], DOM_PROPERTIES = [ ...DOM_BOOLEAN_ATTRIBUTES, "formNoValidate", "isMap", "noModule", "playsInline", "readOnly", "value", "volume", "defaultValue", "defaultChecked", "srcObject", "noValidate", "allowFullscreen", "disablePictureInPicture", "disableRemotePlayback" ], PASSIVE_EVENTS = [ "touchstart", "touchmove" ];

function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}

var STATE_CREATION_RUNES = [ "$state", "$state.raw", "$derived", "$derived.by" ], RUNES = [ ...STATE_CREATION_RUNES, "$state.eager", "$state.snapshot", "$props", "$props.id", "$bindable", "$effect", "$effect.pre", "$effect.tracking", "$effect.root", "$effect.pending", "$inspect", "$inspect().with", "$inspect.trace", "$host" ];

function sanitize_location(location) {
  return null == location ? void 0 : location.replace(/\//g, "/â€‹");
}

var all_styles = new Map;

function register_style(hash2, style) {
  var styles = all_styles.get(hash2);
  if (!styles) {
    styles = new Set;
    all_styles.set(hash2, styles);
  }
  styles.add(style);
}

var all_registered_events = new Set, root_event_handles = new Set;

function create_event(event_name, dom, handler, options = {}) {
  function target_handler(event2) {
    if (!options.capture) handle_event_propagation.call(dom, event2);
    if (!event2.cancelBubble) return without_reactive_context(() => null == handler ? void 0 : handler.call(this, event2));
  }
  if (event_name.startsWith("pointer") || event_name.startsWith("touch") || "wheel" === event_name) queue_micro_task(() => {
    dom.addEventListener(event_name, target_handler, options);
  }); else dom.addEventListener(event_name, target_handler, options);
  return target_handler;
}

function event(event_name, dom, handler, capture2, passive2) {
  var options = {
    capture: capture2,
    passive: passive2
  }, target_handler = create_event(event_name, dom, handler, options);
  if (dom === document.body || dom === window || dom === document || dom instanceof HTMLMediaElement) teardown(() => {
    dom.removeEventListener(event_name, target_handler, options);
  });
}

function delegate(events) {
  for (var i = 0; i < events.length; i++) all_registered_events.add(events[i]);
  for (var fn of root_event_handles) fn(events);
}

var last_propagated_event = null;

function handle_event_propagation(event2) {
  var _a3, owner_document = this.ownerDocument, event_name = event2.type, path = (null == (_a3 = event2.composedPath) ? void 0 : _a3.call(event2)) || [], current_target = path[0] || event2.target, path_idx = 0, handled_at = (last_propagated_event = event2) === event2 && event2.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (-1 !== at_idx && (this === document || this === window)) {
      event2.__root = this;
      return;
    }
    var handler_idx = path.indexOf(this);
    if (-1 === handler_idx) return;
    if (at_idx <= handler_idx) path_idx = at_idx;
  }
  if ((current_target = path[path_idx] || event2.target) !== this) {
    define_property(event2, "currentTarget", {
      configurable: true,
      get: () => current_target || owner_document
    });
    var previous_reaction = active_reaction, previous_effect = active_effect;
    set_active_reaction(null);
    set_active_effect(null);
    try {
      for (var throw_error, other_errors = []; null !== current_target; ) {
        var parent_element = current_target.assignedSlot || current_target.parentNode || current_target.host || null;
        try {
          var delegated = current_target["__" + event_name];
          if (null != delegated && (!current_target.disabled || event2.target === current_target)) delegated.call(current_target, event2);
        } catch (error) {
          if (throw_error) other_errors.push(error); else throw_error = error;
        }
        if (event2.cancelBubble || parent_element === this || null === parent_element) break;
        current_target = parent_element;
      }
      if (throw_error) {
        for (let error of other_errors) queueMicrotask(() => {
          throw error;
        });
        throw throw_error;
      }
    } finally {
      event2.__root = this;
      delete event2.currentTarget;
      set_active_reaction(previous_reaction);
      set_active_effect(previous_effect);
    }
  }
}

function create_fragment_from_html(html2) {
  var elem = document.createElement("template");
  elem.innerHTML = html2.replaceAll("<!>", "\x3c!----\x3e");
  return elem.content;
}

function assign_nodes(start, end) {
  var effect2 = active_effect;
  if (null === effect2.nodes) effect2.nodes = {
    start,
    end,
    a: null,
    t: null
  };
}

function from_html(content, flags2) {
  var node, is_fragment = 0 !== (flags2 & TEMPLATE_FRAGMENT), use_import_node = 0 !== (flags2 & TEMPLATE_USE_IMPORT_NODE), has_start = !content.startsWith("<!>");
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (void 0 === node) {
      node = create_fragment_from_html(has_start ? content : "<!>" + content);
      if (!is_fragment) node = get_first_child(node);
    }
    var clone = use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true);
    if (is_fragment) assign_nodes(get_first_child(clone), clone.lastChild); else assign_nodes(clone, clone);
    return clone;
  };
}

function from_namespace(content, flags2, ns = "svg") {
  var node, has_start = !content.startsWith("<!>"), is_fragment = 0 !== (flags2 & TEMPLATE_FRAGMENT), wrapped = `<${ns}>${has_start ? content : "<!>" + content}</${ns}>`;
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (!node) {
      var root6 = get_first_child(create_fragment_from_html(wrapped));
      if (is_fragment) {
        node = document.createDocumentFragment();
        for (;get_first_child(root6); ) node.appendChild(get_first_child(root6));
      } else node = get_first_child(root6);
    }
    var clone = node.cloneNode(true);
    if (is_fragment) assign_nodes(get_first_child(clone), clone.lastChild); else assign_nodes(clone, clone);
    return clone;
  };
}

function from_svg(content, flags2) {
  return from_namespace(content, flags2, "svg");
}

function comment() {
  if (hydrating) {
    assign_nodes(hydrate_node, null);
    return hydrate_node;
  }
  var frag = document.createDocumentFragment(), start = document.createComment(""), anchor = create_text();
  frag.append(start, anchor);
  assign_nodes(start, anchor);
  return frag;
}

function append(anchor, dom) {
  if (!hydrating) {
    if (null !== anchor) anchor.before(dom);
  } else {
    var effect2 = active_effect;
    if (0 === (effect2.f & EFFECT_RAN) || null === effect2.nodes.end) effect2.nodes.end = hydrate_node;
    hydrate_next();
  }
}

var should_intro = true;

function set_text(text2, value) {
  var _a3, str = null == value ? "" : "object" == typeof value ? value + "" : value;
  if (str !== (null != (_a3 = text2.__t) ? _a3 : text2.__t = text2.nodeValue)) {
    text2.__t = str;
    text2.nodeValue = str + "";
  }
}

function mount(component2, options) {
  return _mount(component2, options);
}

function hydrate(component2, options) {
  var _a3;
  init_operations();
  options.intro = null != (_a3 = options.intro) ? _a3 : false;
  const target = options.target, was_hydrating = hydrating, previous_hydrate_node = hydrate_node;
  try {
    for (var anchor = get_first_child(target); anchor && (anchor.nodeType !== COMMENT_NODE || anchor.data !== HYDRATION_START); ) anchor = get_next_sibling(anchor);
    if (!anchor) throw HYDRATION_ERROR;
    set_hydrating(true);
    set_hydrate_node(anchor);
    const instance = _mount(component2, {
      ...options,
      anchor
    });
    set_hydrating(false);
    return instance;
  } catch (error) {
    if (error instanceof Error && error.message.split("\n").some(line => line.startsWith("https://svelte.dev/e/"))) throw error;
    if (error !== HYDRATION_ERROR) console.warn("Failed to hydrate: ", error);
    if (false === options.recover) hydration_failed();
    init_operations();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component2, options);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
  }
}

var document_listeners = new Map;

function _mount(Component, {target, anchor, props = {}, events, context, intro = true}) {
  init_operations();
  var registered_events = new Set, event_handle = events2 => {
    for (var i = 0; i < events2.length; i++) {
      var event_name = events2[i];
      if (!registered_events.has(event_name)) {
        registered_events.add(event_name);
        var passive2 = is_passive_event(event_name);
        target.addEventListener(event_name, handle_event_propagation, {
          passive: passive2
        });
        var n = document_listeners.get(event_name);
        if (void 0 === n) {
          document.addEventListener(event_name, handle_event_propagation, {
            passive: passive2
          });
          document_listeners.set(event_name, 1);
        } else document_listeners.set(event_name, n + 1);
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component2 = void 0, unmount2 = component_root(() => {
    var anchor_node = null != anchor ? anchor : target.appendChild(create_text());
    boundary(anchor_node, {
      pending: () => {}
    }, anchor_node2 => {
      if (context) {
        push({});
        component_context.c = context;
      }
      if (events) props.$$events = events;
      if (hydrating) assign_nodes(anchor_node2, null);
      should_intro = intro;
      component2 = Component(anchor_node2, props) || {};
      should_intro = true;
      if (hydrating) {
        active_effect.nodes.end = hydrate_node;
        if (null === hydrate_node || hydrate_node.nodeType !== COMMENT_NODE || hydrate_node.data !== HYDRATION_END) {
          hydration_mismatch();
          throw HYDRATION_ERROR;
        }
      }
      if (context) pop();
    });
    return () => {
      var _a3;
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n = document_listeners.get(event_name);
        if (0 === --n) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else document_listeners.set(event_name, n);
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) null == (_a3 = anchor_node.parentNode) || _a3.removeChild(anchor_node);
    };
  });
  mounted_components.set(component2, unmount2);
  return component2;
}

var _batches, _onscreen, _offscreen, _outroing, _transition, _commit, _discard, mounted_components = new WeakMap;

function unmount(component2, options) {
  const fn = mounted_components.get(component2);
  if (fn) {
    mounted_components.delete(component2);
    return fn(options);
  }
  if (dev_fallback_default) if (STATE_SYMBOL in component2) state_proxy_unmount(); else lifecycle_double_unmount();
  return Promise.resolve();
}

var offscreen_anchor, BranchManager = class {
  constructor(anchor, transition2 = true) {
    __publicField(this, "anchor");
    __privateAdd(this, _batches, new Map);
    __privateAdd(this, _onscreen, new Map);
    __privateAdd(this, _offscreen, new Map);
    __privateAdd(this, _outroing, new Set);
    __privateAdd(this, _transition, true);
    __privateAdd(this, _commit, () => {
      var batch = current_batch;
      if (__privateGet(this, _batches).has(batch)) {
        var key2 = __privateGet(this, _batches).get(batch), onscreen = __privateGet(this, _onscreen).get(key2);
        if (onscreen) {
          resume_effect(onscreen);
          __privateGet(this, _outroing).delete(key2);
        } else {
          var offscreen = __privateGet(this, _offscreen).get(key2);
          if (offscreen) {
            __privateGet(this, _onscreen).set(key2, offscreen.effect);
            __privateGet(this, _offscreen).delete(key2);
            offscreen.fragment.lastChild.remove();
            this.anchor.before(offscreen.fragment);
            onscreen = offscreen.effect;
          }
        }
        for (const [b, k] of __privateGet(this, _batches)) {
          __privateGet(this, _batches).delete(b);
          if (b === batch) break;
          const offscreen2 = __privateGet(this, _offscreen).get(k);
          if (offscreen2) {
            destroy_effect(offscreen2.effect);
            __privateGet(this, _offscreen).delete(k);
          }
        }
        for (const [k, effect2] of __privateGet(this, _onscreen)) {
          if (k === key2 || __privateGet(this, _outroing).has(k)) continue;
          const on_destroy = () => {
            if (Array.from(__privateGet(this, _batches).values()).includes(k)) {
              var fragment = document.createDocumentFragment();
              move_effect(effect2, fragment);
              fragment.append(create_text());
              __privateGet(this, _offscreen).set(k, {
                effect: effect2,
                fragment
              });
            } else destroy_effect(effect2);
            __privateGet(this, _outroing).delete(k);
            __privateGet(this, _onscreen).delete(k);
          };
          if (__privateGet(this, _transition) || !onscreen) {
            __privateGet(this, _outroing).add(k);
            pause_effect(effect2, on_destroy, false);
          } else on_destroy();
        }
      }
    });
    __privateAdd(this, _discard, batch => {
      __privateGet(this, _batches).delete(batch);
      const keys = Array.from(__privateGet(this, _batches).values());
      for (const [k, branch2] of __privateGet(this, _offscreen)) if (!keys.includes(k)) {
        destroy_effect(branch2.effect);
        __privateGet(this, _offscreen).delete(k);
      }
    });
    this.anchor = anchor;
    __privateSet(this, _transition, transition2);
  }
  ensure(key2, fn) {
    var batch = current_batch, defer = should_defer_append();
    if (fn && !__privateGet(this, _onscreen).has(key2) && !__privateGet(this, _offscreen).has(key2)) if (defer) {
      var fragment = document.createDocumentFragment(), target = create_text();
      fragment.append(target);
      __privateGet(this, _offscreen).set(key2, {
        effect: branch(() => fn(target)),
        fragment
      });
    } else __privateGet(this, _onscreen).set(key2, branch(() => fn(this.anchor)));
    __privateGet(this, _batches).set(batch, key2);
    if (defer) {
      for (const [k, effect2] of __privateGet(this, _onscreen)) if (k === key2) batch.skipped_effects.delete(effect2); else batch.skipped_effects.add(effect2);
      for (const [k, branch2] of __privateGet(this, _offscreen)) if (k === key2) batch.skipped_effects.delete(branch2.effect); else batch.skipped_effects.add(branch2.effect);
      batch.oncommit(__privateGet(this, _commit));
      batch.ondiscard(__privateGet(this, _discard));
    } else {
      if (hydrating) this.anchor = hydrate_node;
      __privateGet(this, _commit).call(this);
    }
  }
};

_batches = new WeakMap;

_onscreen = new WeakMap;

_offscreen = new WeakMap;

_outroing = new WeakMap;

_transition = new WeakMap;

_commit = new WeakMap;

_discard = new WeakMap;

function if_block(node, fn, elseif = false) {
  if (hydrating) hydrate_next();
  var branches = new BranchManager(node);
  function update_branch(condition, fn2) {
    if (hydrating) if (condition === (read_hydration_instruction(node) === HYDRATION_START_ELSE)) {
      var anchor = skip_nodes();
      set_hydrate_node(anchor);
      branches.anchor = anchor;
      set_hydrating(false);
      branches.ensure(condition, fn2);
      set_hydrating(true);
      return;
    }
    branches.ensure(condition, fn2);
  }
  block(() => {
    var has_branch = false;
    fn((fn2, flag = true) => {
      has_branch = true;
      update_branch(flag, fn2);
    });
    if (!has_branch) update_branch(false, null);
  }, elseif ? EFFECT_TRANSPARENT : 0);
}

function index(_, i) {
  return i;
}

function pause_effects(state2, to_destroy, controlled_anchor) {
  for (var _a3, group, length = to_destroy.length, remaining = to_destroy.length, i = 0; i < length; i++) {
    let effect2 = to_destroy[i];
    pause_effect(effect2, () => {
      if (group) {
        group.pending.delete(effect2);
        group.done.add(effect2);
        if (0 === group.pending.size) {
          var groups = state2.outrogroups;
          destroy_effects(array_from(group.done));
          groups.delete(group);
          if (0 === groups.size) state2.outrogroups = null;
        }
      } else remaining -= 1;
    }, false);
  }
  if (0 === remaining) {
    var fast_path = null !== controlled_anchor;
    if (fast_path) {
      var anchor = controlled_anchor, parent_node = anchor.parentNode;
      clear_text_content(parent_node);
      parent_node.append(anchor);
      state2.items.clear();
    }
    destroy_effects(to_destroy, !fast_path);
  } else {
    group = {
      pending: new Set(to_destroy),
      done: new Set
    };
    (null != (_a3 = state2.outrogroups) ? _a3 : state2.outrogroups = new Set).add(group);
  }
}

function destroy_effects(to_destroy, remove_dom = true) {
  for (var i = 0; i < to_destroy.length; i++) destroy_effect(to_destroy[i], remove_dom);
}

function each(node, flags2, get_collection, get_key, render_fn, fallback_fn = null) {
  var anchor = node, items = new Map;
  if (0 !== (flags2 & EACH_IS_CONTROLLED)) {
    var parent_node = node;
    anchor = hydrating ? set_hydrate_node(get_first_child(parent_node)) : parent_node.appendChild(create_text());
  }
  if (hydrating) hydrate_next();
  var array, fallback2 = null, each_array = derived_safe_equal(() => {
    var collection = get_collection();
    return is_array(collection) ? collection : null == collection ? [] : array_from(collection);
  }), first_run = true;
  function commit() {
    state2.fallback = fallback2;
    reconcile(state2, array, anchor, flags2, get_key);
    if (null !== fallback2) if (0 === array.length) if (0 === (fallback2.f & EFFECT_OFFSCREEN)) resume_effect(fallback2); else {
      fallback2.f ^= EFFECT_OFFSCREEN;
      move(fallback2, null, anchor);
    } else pause_effect(fallback2, () => {
      fallback2 = null;
    });
  }
  var state2 = {
    effect: block(() => {
      var length = (array = get(each_array)).length;
      let mismatch = false;
      if (hydrating) if (read_hydration_instruction(anchor) === HYDRATION_START_ELSE != (0 === length)) {
        set_hydrate_node(anchor = skip_nodes());
        set_hydrating(false);
        mismatch = true;
      }
      for (var keys = new Set, batch = current_batch, defer = should_defer_append(), index2 = 0; index2 < length; index2 += 1) {
        if (hydrating && hydrate_node.nodeType === COMMENT_NODE && hydrate_node.data === HYDRATION_END) {
          anchor = hydrate_node;
          mismatch = true;
          set_hydrating(false);
        }
        var value = array[index2], key2 = get_key(value, index2), item = first_run ? null : items.get(key2);
        if (item) {
          if (item.v) internal_set(item.v, value);
          if (item.i) internal_set(item.i, index2);
          if (defer) batch.skipped_effects.delete(item.e);
        } else {
          item = create_item(items, first_run ? anchor : null != offscreen_anchor ? offscreen_anchor : offscreen_anchor = create_text(), value, key2, index2, render_fn, flags2, get_collection);
          if (!first_run) item.e.f |= EFFECT_OFFSCREEN;
          items.set(key2, item);
        }
        keys.add(key2);
      }
      if (0 === length && fallback_fn && !fallback2) if (first_run) fallback2 = branch(() => fallback_fn(anchor)); else (fallback2 = branch(() => fallback_fn(null != offscreen_anchor ? offscreen_anchor : offscreen_anchor = create_text()))).f |= EFFECT_OFFSCREEN;
      if (hydrating && length > 0) set_hydrate_node(skip_nodes());
      if (!first_run) if (defer) {
        for (const [key3, item2] of items) if (!keys.has(key3)) batch.skipped_effects.add(item2.e);
        batch.oncommit(commit);
        batch.ondiscard(() => {});
      } else commit();
      if (mismatch) set_hydrating(true);
      get(each_array);
    }),
    flags: flags2,
    items,
    outrogroups: null,
    fallback: fallback2
  };
  first_run = false;
  if (hydrating) anchor = hydrate_node;
}

function reconcile(state2, array, anchor, flags2, get_key) {
  var _a3, _b3, _c2, _d, _e, _f, _g, _h, _i, seen, to_animate, key2, effect2, i, is_animated = 0 !== (flags2 & EACH_IS_ANIMATED), length = array.length, items = state2.items, current = state2.effect.first, prev = null, matched = [], stashed = [];
  if (is_animated) for (i = 0; i < length; i += 1) {
    key2 = get_key(array[i], i);
    if (0 === ((effect2 = items.get(key2).e).f & EFFECT_OFFSCREEN)) {
      null == (_b3 = null == (_a3 = effect2.nodes) ? void 0 : _a3.a) || _b3.measure();
      (null != to_animate ? to_animate : to_animate = new Set).add(effect2);
    }
  }
  for (i = 0; i < length; i += 1) {
    key2 = get_key(array[i], i);
    effect2 = items.get(key2).e;
    if (null !== state2.outrogroups) for (const group of state2.outrogroups) {
      group.pending.delete(effect2);
      group.done.delete(effect2);
    }
    if (0 !== (effect2.f & EFFECT_OFFSCREEN)) {
      effect2.f ^= EFFECT_OFFSCREEN;
      if (effect2 === current) move(effect2, null, anchor); else {
        var next2 = prev ? prev.next : current;
        if (effect2 === state2.effect.last) state2.effect.last = effect2.prev;
        if (effect2.prev) effect2.prev.next = effect2.next;
        if (effect2.next) effect2.next.prev = effect2.prev;
        link(state2, prev, effect2);
        link(state2, effect2, next2);
        move(effect2, next2, anchor);
        matched = [];
        stashed = [];
        current = (prev = effect2).next;
        continue;
      }
    }
    if (0 !== (effect2.f & INERT)) {
      resume_effect(effect2);
      if (is_animated) {
        null == (_d = null == (_c2 = effect2.nodes) ? void 0 : _c2.a) || _d.unfix();
        (null != to_animate ? to_animate : to_animate = new Set).delete(effect2);
      }
    }
    if (effect2 !== current) {
      if (void 0 !== seen && seen.has(effect2)) {
        if (matched.length < stashed.length) {
          var j, start = stashed[0];
          prev = start.prev;
          var a = matched[0], b = matched[matched.length - 1];
          for (j = 0; j < matched.length; j += 1) move(matched[j], start, anchor);
          for (j = 0; j < stashed.length; j += 1) seen.delete(stashed[j]);
          link(state2, a.prev, b.next);
          link(state2, prev, a);
          link(state2, b, start);
          current = start;
          prev = b;
          i -= 1;
          matched = [];
          stashed = [];
        } else {
          seen.delete(effect2);
          move(effect2, current, anchor);
          link(state2, effect2.prev, effect2.next);
          link(state2, effect2, null === prev ? state2.effect.first : prev.next);
          link(state2, prev, effect2);
          prev = effect2;
        }
        continue;
      }
      matched = [];
      stashed = [];
      for (;null !== current && current !== effect2; ) {
        (null != seen ? seen : seen = new Set).add(current);
        stashed.push(current);
        current = current.next;
      }
      if (null === current) continue;
    }
    if (0 === (effect2.f & EFFECT_OFFSCREEN)) matched.push(effect2);
    prev = effect2;
    current = effect2.next;
  }
  if (null !== state2.outrogroups) {
    for (const group of state2.outrogroups) if (0 === group.pending.size) {
      destroy_effects(array_from(group.done));
      null == (_e = state2.outrogroups) || _e.delete(group);
    }
    if (0 === state2.outrogroups.size) state2.outrogroups = null;
  }
  if (null !== current || void 0 !== seen) {
    var to_destroy = [];
    if (void 0 !== seen) for (effect2 of seen) if (0 === (effect2.f & INERT)) to_destroy.push(effect2);
    for (;null !== current; ) {
      if (0 === (current.f & INERT) && current !== state2.fallback) to_destroy.push(current);
      current = current.next;
    }
    var destroy_length = to_destroy.length;
    if (destroy_length > 0) {
      var controlled_anchor = 0 !== (flags2 & EACH_IS_CONTROLLED) && 0 === length ? anchor : null;
      if (is_animated) {
        for (i = 0; i < destroy_length; i += 1) null == (_g = null == (_f = to_destroy[i].nodes) ? void 0 : _f.a) || _g.measure();
        for (i = 0; i < destroy_length; i += 1) null == (_i = null == (_h = to_destroy[i].nodes) ? void 0 : _h.a) || _i.fix();
      }
      pause_effects(state2, to_destroy, controlled_anchor);
    }
  }
  if (is_animated) queue_micro_task(() => {
    var _a4, _b4;
    if (void 0 !== to_animate) for (effect2 of to_animate) null == (_b4 = null == (_a4 = effect2.nodes) ? void 0 : _a4.a) || _b4.apply();
  });
}

function create_item(items, anchor, value, key2, index2, render_fn, flags2, get_collection) {
  var v = 0 !== (flags2 & EACH_ITEM_REACTIVE) ? 0 === (flags2 & EACH_ITEM_IMMUTABLE) ? mutable_source(value, false, false) : source(value) : null, i = 0 !== (flags2 & EACH_INDEX_REACTIVE) ? source(index2) : null;
  if (dev_fallback_default && v) v.trace = () => {
    var _a3;
    get_collection()[null != (_a3 = null == i ? void 0 : i.v) ? _a3 : index2];
  };
  return {
    v,
    i,
    e: branch(() => {
      render_fn(anchor, null != v ? v : value, null != i ? i : index2, get_collection);
      return () => {
        items.delete(key2);
      };
    })
  };
}

function move(effect2, next2, anchor) {
  if (effect2.nodes) for (var node = effect2.nodes.start, end = effect2.nodes.end, dest = next2 && 0 === (next2.f & EFFECT_OFFSCREEN) ? next2.nodes.start : anchor; null !== node; ) {
    var next_node = get_next_sibling(node);
    dest.before(node);
    if (node === end) return;
    node = next_node;
  }
}

function link(state2, prev, next2) {
  if (null === prev) state2.effect.first = next2; else prev.next = next2;
  if (null === next2) state2.effect.last = prev; else next2.prev = prev;
}

function check_hash(element2, server_hash, value) {
  var _a3, _b3;
  if (!server_hash || server_hash === hash(String(null != value ? value : ""))) return;
  let location;
  const loc = null == (_a3 = element2.__svelte_meta) ? void 0 : _a3.loc;
  if (loc) location = `near ${loc.file}:${loc.line}:${loc.column}`; else if (null == (_b3 = dev_current_component_function) ? void 0 : _b3[FILENAME]) location = `in ${dev_current_component_function[FILENAME]}`;
  hydration_html_changed(sanitize_location(location));
}

function html(node, get_value, svg = false, mathml = false, skip_warning = false) {
  var anchor = node, value = "";
  template_effect(() => {
    var _a3, effect2 = active_effect;
    if (value !== (value = null != (_a3 = get_value()) ? _a3 : "")) {
      if (null !== effect2.nodes) {
        remove_effect_dom(effect2.nodes.start, effect2.nodes.end);
        effect2.nodes = null;
      }
      if ("" !== value) if (!hydrating) {
        var html2 = value + "";
        if (svg) html2 = `<svg>${html2}</svg>`; else if (mathml) html2 = `<math>${html2}</math>`;
        var node2 = create_fragment_from_html(html2);
        if (svg || mathml) node2 = get_first_child(node2);
        assign_nodes(get_first_child(node2), node2.lastChild);
        if (svg || mathml) for (;get_first_child(node2); ) anchor.before(get_first_child(node2)); else anchor.before(node2);
      } else {
        for (var hash2 = hydrate_node.data, next2 = hydrate_next(), last = next2; null !== next2 && (next2.nodeType !== COMMENT_NODE || "" !== next2.data); ) {
          last = next2;
          next2 = get_next_sibling(next2);
        }
        if (null === next2) {
          hydration_mismatch();
          throw HYDRATION_ERROR;
        }
        if (dev_fallback_default && !skip_warning) check_hash(next2.parentNode, hash2, value);
        assign_nodes(hydrate_node, last);
        anchor = set_hydrate_node(next2);
      }
    } else if (hydrating) hydrate_next();
  });
}

function snippet(node, get_snippet, ...args) {
  var branches = new BranchManager(node);
  block(() => {
    var _a3;
    const snippet2 = null != (_a3 = get_snippet()) ? _a3 : null;
    if (dev_fallback_default && null == snippet2) invalid_snippet();
    branches.ensure(snippet2, snippet2 && (anchor => snippet2(anchor, ...args)));
  }, EFFECT_TRANSPARENT);
}

function append_styles(anchor, css) {
  effect(() => {
    var _a3, root6 = anchor.getRootNode(), target = root6.host ? root6 : null != (_a3 = root6.head) ? _a3 : root6.ownerDocument.head;
    if (!target.querySelector("#" + css.hash)) {
      const style = document.createElement("style");
      style.id = css.hash;
      style.textContent = css.code;
      target.appendChild(style);
      if (dev_fallback_default) register_style(css.hash, style);
    }
  });
}

function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e; else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}

function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), 
  n += t);
  return n;
}

function clsx2(value) {
  if ("object" == typeof value) return clsx(value); else return null != value ? value : "";
}

var whitespace = [ ..." \t\n\r\fÂ \v\ufeff" ];

function to_class(value, hash2, directives) {
  var classname = null == value ? "" : "" + value;
  if (hash2) classname = classname ? classname + " " + hash2 : hash2;
  if (directives) for (var key2 in directives) if (directives[key2]) classname = classname ? classname + " " + key2 : key2; else if (classname.length) for (var len = key2.length, a = 0; (a = classname.indexOf(key2, a)) >= 0; ) {
    var b = a + len;
    if ((0 === a || whitespace.includes(classname[a - 1])) && (b === classname.length || whitespace.includes(classname[b]))) classname = (0 === a ? "" : classname.substring(0, a)) + classname.substring(b + 1); else a = b;
  }
  return "" === classname ? null : classname;
}

function append_styles2(styles, important = false) {
  var separator = important ? " !important;" : ";", css = "";
  for (var key2 in styles) {
    var value = styles[key2];
    if (null != value && "" !== value) css += " " + key2 + ": " + value + separator;
  }
  return css;
}

function to_css_name(name) {
  if ("-" !== name[0] || "-" !== name[1]) return name.toLowerCase(); else return name;
}

function to_style(value, styles) {
  if (styles) {
    var normal_styles, important_styles, new_style = "";
    if (Array.isArray(styles)) {
      normal_styles = styles[0];
      important_styles = styles[1];
    } else normal_styles = styles;
    if (value) {
      value = String(value).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var in_str = false, in_apo = 0, in_comment = false, reserved_names = [];
      if (normal_styles) reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
      if (important_styles) reserved_names.push(...Object.keys(important_styles).map(to_css_name));
      var start_index = 0, name_index = -1;
      const len = value.length;
      for (var i = 0; i < len; i++) {
        var c = value[i];
        if (in_comment) {
          if ("/" === c && "*" === value[i - 1]) in_comment = false;
        } else if (in_str) {
          if (in_str === c) in_str = false;
        } else if ("/" === c && "*" === value[i + 1]) in_comment = true; else if ('"' === c || "'" === c) in_str = c; else if ("(" === c) in_apo++; else if (")" === c) in_apo--;
        if (!in_comment && false === in_str && 0 === in_apo) if (":" === c && -1 === name_index) name_index = i; else if (";" === c || i === len - 1) {
          if (-1 !== name_index) {
            var name = to_css_name(value.substring(start_index, name_index).trim());
            if (!reserved_names.includes(name)) {
              if (";" !== c) i++;
              new_style += " " + value.substring(start_index, i).trim() + ";";
            }
          }
          start_index = i + 1;
          name_index = -1;
        }
      }
    }
    if (normal_styles) new_style += append_styles2(normal_styles);
    if (important_styles) new_style += append_styles2(important_styles, true);
    return "" === (new_style = new_style.trim()) ? null : new_style;
  }
  return null == value ? null : String(value);
}

function set_class(dom, is_html, value, hash2, prev_classes, next_classes) {
  var prev = dom.__className;
  if (hydrating || prev !== value || void 0 === prev) {
    var next_class_name = to_class(value, hash2, next_classes);
    if (!hydrating || next_class_name !== dom.getAttribute("class")) if (null == next_class_name) dom.removeAttribute("class"); else if (is_html) dom.className = next_class_name; else dom.setAttribute("class", next_class_name);
    dom.__className = value;
  } else if (next_classes && prev_classes !== next_classes) for (var key2 in next_classes) {
    var is_present = !!next_classes[key2];
    if (null == prev_classes || is_present !== !!prev_classes[key2]) dom.classList.toggle(key2, is_present);
  }
  return next_classes;
}

function update_styles(dom, prev = {}, next2, priority) {
  for (var key2 in next2) {
    var value = next2[key2];
    if (prev[key2] !== value) if (null == next2[key2]) dom.style.removeProperty(key2); else dom.style.setProperty(key2, value, priority);
  }
}

function set_style(dom, value, prev_styles, next_styles) {
  var prev = dom.__style;
  if (hydrating || prev !== value) {
    var next_style_attr = to_style(value, next_styles);
    if (!hydrating || next_style_attr !== dom.getAttribute("style")) if (null == next_style_attr) dom.removeAttribute("style"); else dom.style.cssText = next_style_attr;
    dom.__style = value;
  } else if (next_styles) if (Array.isArray(next_styles)) {
    update_styles(dom, null == prev_styles ? void 0 : prev_styles[0], next_styles[0]);
    update_styles(dom, null == prev_styles ? void 0 : prev_styles[1], next_styles[1], "important");
  } else update_styles(dom, prev_styles, next_styles);
  return next_styles;
}

var IS_CUSTOM_ELEMENT = Symbol("is custom element"), IS_HTML = Symbol("is html");

function remove_input_defaults(input) {
  if (hydrating) {
    var already_removed = false, remove_defaults = () => {
      if (!already_removed) {
        already_removed = true;
        if (input.hasAttribute("value")) {
          var value = input.value;
          set_attribute2(input, "value", null);
          input.value = value;
        }
        if (input.hasAttribute("checked")) {
          var checked = input.checked;
          set_attribute2(input, "checked", null);
          input.checked = checked;
        }
      }
    };
    input.__on_r = remove_defaults;
    queue_micro_task(remove_defaults);
    add_form_reset_listener();
  }
}

function set_attribute2(element2, attribute, value, skip_warning) {
  var attributes = get_attributes(element2);
  if (hydrating) {
    attributes[attribute] = element2.getAttribute(attribute);
    if ("src" === attribute || "srcset" === attribute || "href" === attribute && "LINK" === element2.nodeName) {
      if (!skip_warning) check_src_in_dev_hydration(element2, attribute, null != value ? value : "");
      return;
    }
  }
  if (attributes[attribute] !== (attributes[attribute] = value)) {
    if ("loading" === attribute) element2[LOADING_ATTR_SYMBOL] = value;
    if (null == value) element2.removeAttribute(attribute); else if ("string" != typeof value && get_setters(element2).includes(attribute)) element2[attribute] = value; else element2.setAttribute(attribute, value);
  }
}

function get_attributes(element2) {
  var _a3;
  return null != (_a3 = element2.__attributes) ? _a3 : element2.__attributes = {
    [IS_CUSTOM_ELEMENT]: element2.nodeName.includes("-"),
    [IS_HTML]: element2.namespaceURI === NAMESPACE_HTML
  };
}

var setters_cache = new Map;

function get_setters(element2) {
  var descriptors, cache_key = element2.getAttribute("is") || element2.nodeName, setters = setters_cache.get(cache_key);
  if (setters) return setters;
  setters_cache.set(cache_key, setters = []);
  for (var proto = element2, element_proto = Element.prototype; element_proto !== proto; ) {
    descriptors = get_descriptors(proto);
    for (var key2 in descriptors) if (descriptors[key2].set) setters.push(key2);
    proto = get_prototype_of(proto);
  }
  return setters;
}

function check_src_in_dev_hydration(element2, attribute, value) {
  var _a3;
  if (dev_fallback_default) if ("srcset" !== attribute || !srcset_url_equal(element2, value)) if (!src_url_equal(null != (_a3 = element2.getAttribute(attribute)) ? _a3 : "", value)) hydration_attribute_changed(attribute, element2.outerHTML.replace(element2.innerHTML, element2.innerHTML && "..."), String(value));
}

function src_url_equal(element_src, url) {
  if (element_src === url) return true; else return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
}

function split_srcset(srcset) {
  return srcset.split(",").map(src => src.trim().split(" ").filter(Boolean));
}

function srcset_url_equal(element2, srcset) {
  var element_urls = split_srcset(element2.srcset), urls = split_srcset(srcset);
  return urls.length === element_urls.length && urls.every(([url, width], i) => width === element_urls[i][1] && (src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0])));
}

function bind_value(input, get3, set2 = get3) {
  var batches2 = new WeakSet;
  listen_to_event_and_reset_event(input, "input", async is_reset => {
    if (dev_fallback_default && "checkbox" === input.type) bind_invalid_checkbox_value();
    var value = is_reset ? input.defaultValue : input.value;
    value = is_numberlike_input(input) ? to_number(value) : value;
    set2(value);
    if (null !== current_batch) batches2.add(current_batch);
    await tick();
    if (value !== (value = get3())) {
      var start = input.selectionStart, end = input.selectionEnd, length = input.value.length;
      input.value = null != value ? value : "";
      if (null !== end) {
        var new_length = input.value.length;
        if (start === end && end === length && new_length > length) {
          input.selectionStart = new_length;
          input.selectionEnd = new_length;
        } else {
          input.selectionStart = start;
          input.selectionEnd = Math.min(end, new_length);
        }
      }
    }
  });
  if (hydrating && input.defaultValue !== input.value || null == untrack(get3) && input.value) {
    set2(is_numberlike_input(input) ? to_number(input.value) : input.value);
    if (null !== current_batch) batches2.add(current_batch);
  }
  render_effect(() => {
    var _a3;
    if (dev_fallback_default && "checkbox" === input.type) bind_invalid_checkbox_value();
    var value = get3();
    if (input === document.activeElement) {
      var batch = null != (_a3 = previous_batch) ? _a3 : current_batch;
      if (batches2.has(batch)) return;
    }
    if (!is_numberlike_input(input) || value !== to_number(input.value)) if ("date" !== input.type || value || input.value) if (value !== input.value) input.value = null != value ? value : "";
  });
}

function is_numberlike_input(input) {
  var type = input.type;
  return "number" === type || "range" === type;
}

function to_number(value) {
  return "" === value ? null : +value;
}

function is_bound_this(bound_value, element_or_component) {
  return bound_value === element_or_component || (null == bound_value ? void 0 : bound_value[STATE_SYMBOL]) === element_or_component;
}

function bind_this(element_or_component = {}, update2, get_value, get_parts) {
  effect(() => {
    var old_parts, parts;
    render_effect(() => {
      old_parts = parts;
      parts = (null == get_parts ? void 0 : get_parts()) || [];
      untrack(() => {
        if (element_or_component !== get_value(...parts)) {
          update2(element_or_component, ...parts);
          if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) update2(null, ...old_parts);
        }
      });
    });
    return () => {
      queue_micro_task(() => {
        if (parts && is_bound_this(get_value(...parts), element_or_component)) update2(null, ...parts);
      });
    };
  });
  return element_or_component;
}

var _events, _instance, is_store_binding = false, IS_UNMOUNTED = Symbol();

function store_get(store, store_name, stores) {
  var _a3;
  const entry = null != (_a3 = stores[store_name]) ? _a3 : stores[store_name] = {
    store: null,
    source: mutable_source(void 0),
    unsubscribe: noop
  };
  if (dev_fallback_default) entry.source.label = store_name;
  if (entry.store !== store && !(IS_UNMOUNTED in stores)) {
    entry.unsubscribe();
    entry.store = null != store ? store : null;
    if (null == store) {
      entry.source.v = void 0;
      entry.unsubscribe = noop;
    } else {
      var is_synchronous_callback = true;
      entry.unsubscribe = subscribe_to_store(store, v => {
        if (is_synchronous_callback) entry.source.v = v; else set(entry.source, v);
      });
      is_synchronous_callback = false;
    }
  }
  if (store && IS_UNMOUNTED in stores) return get2(store); else return get(entry.source);
}

function store_set(store, value) {
  store.set(value);
  return value;
}

function setup_stores() {
  const stores = {};
  return [ stores, function cleanup() {
    teardown(() => {
      for (var store_name in stores) stores[store_name].unsubscribe();
      define_property(stores, IS_UNMOUNTED, {
        enumerable: false,
        value: true
      });
    });
  } ];
}

function capture_store_binding(fn) {
  var previous_is_store_binding = is_store_binding;
  try {
    is_store_binding = false;
    return [ fn(), is_store_binding ];
  } finally {
    is_store_binding = previous_is_store_binding;
  }
}

function prop(props, key2, flags2, fallback2) {
  var _a3, _b3, setter, initial_value, runes = !legacy_mode_flag || 0 !== (flags2 & PROPS_IS_RUNES), bindable = 0 !== (flags2 & PROPS_IS_BINDABLE), lazy = 0 !== (flags2 & PROPS_IS_LAZY_INITIAL), fallback_value = fallback2, fallback_dirty = true, get_fallback = () => {
    if (fallback_dirty) {
      fallback_dirty = false;
      fallback_value = lazy ? untrack(fallback2) : fallback2;
    }
    return fallback_value;
  };
  if (bindable) {
    var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
    setter = null != (_b3 = null == (_a3 = get_descriptor(props, key2)) ? void 0 : _a3.set) ? _b3 : is_entry_props && key2 in props ? v => props[key2] = v : void 0;
  }
  var getter, is_store_sub = false;
  if (bindable) [initial_value, is_store_sub] = capture_store_binding(() => props[key2]); else initial_value = props[key2];
  if (void 0 === initial_value && void 0 !== fallback2) {
    initial_value = get_fallback();
    if (setter) {
      if (runes) props_invalid_value(key2);
      setter(initial_value);
    }
  }
  if (runes) getter = () => {
    var value = props[key2];
    if (void 0 === value) return get_fallback();
    fallback_dirty = true;
    return value;
  }; else getter = () => {
    var value = props[key2];
    if (void 0 !== value) fallback_value = void 0;
    return void 0 === value ? fallback_value : value;
  };
  if (runes && 0 === (flags2 & PROPS_IS_UPDATED)) return getter;
  if (setter) {
    var legacy_parent = props.$$legacy;
    return function(value, mutation) {
      if (arguments.length > 0) {
        if (!runes || !mutation || legacy_parent || is_store_sub) setter(mutation ? getter() : value);
        return value;
      }
      return getter();
    };
  }
  var overridden = false, d = (0 !== (flags2 & PROPS_IS_IMMUTABLE) ? derived : derived_safe_equal)(() => {
    overridden = false;
    return getter();
  });
  if (dev_fallback_default) d.label = key2;
  if (bindable) get(d);
  var parent_effect = active_effect;
  return function(value, mutation) {
    if (arguments.length > 0) {
      const new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;
      set(d, new_value);
      overridden = true;
      if (void 0 !== fallback_value) fallback_value = new_value;
      return value;
    }
    if (is_destroying_effect && overridden || 0 !== (parent_effect.f & DESTROYED)) return d.v; else return get(d);
  };
}

function createClassComponent(options) {
  return new Svelte4Component(options);
}

var SvelteElement, Svelte4Component = class {
  constructor(options) {
    __privateAdd(this, _events);
    __privateAdd(this, _instance);
    var _a3, _b3, sources = new Map, add_source = (key2, value) => {
      var s = mutable_source(value, false, false);
      sources.set(key2, s);
      return s;
    };
    const props = new Proxy({
      ...options.props || {},
      $$events: {}
    }, {
      get(target, prop2) {
        var _a4;
        return get(null != (_a4 = sources.get(prop2)) ? _a4 : add_source(prop2, Reflect.get(target, prop2)));
      },
      has(target, prop2) {
        var _a4;
        if (prop2 === LEGACY_PROPS) return true;
        get(null != (_a4 = sources.get(prop2)) ? _a4 : add_source(prop2, Reflect.get(target, prop2)));
        return Reflect.has(target, prop2);
      },
      set(target, prop2, value) {
        var _a4;
        set(null != (_a4 = sources.get(prop2)) ? _a4 : add_source(prop2, value), value);
        return Reflect.set(target, prop2, value);
      }
    });
    __privateSet(this, _instance, (options.hydrate ? hydrate : mount)(options.component, {
      target: options.target,
      anchor: options.anchor,
      props,
      context: options.context,
      intro: null != (_a3 = options.intro) ? _a3 : false,
      recover: options.recover
    }));
    if (!(async_mode_flag || (null == (_b3 = null == options ? void 0 : options.props) ? void 0 : _b3.$$host) && false !== options.sync)) flushSync();
    __privateSet(this, _events, props.$$events);
    for (const key2 of Object.keys(__privateGet(this, _instance))) if ("$set" !== key2 && "$destroy" !== key2 && "$on" !== key2) define_property(this, key2, {
      get() {
        return __privateGet(this, _instance)[key2];
      },
      set(value) {
        __privateGet(this, _instance)[key2] = value;
      },
      enumerable: true
    });
    __privateGet(this, _instance).$set = next2 => {
      Object.assign(props, next2);
    };
    __privateGet(this, _instance).$destroy = () => {
      unmount(__privateGet(this, _instance));
    };
  }
  $set(props) {
    __privateGet(this, _instance).$set(props);
  }
  $on(event2, callback) {
    __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2] || [];
    const cb = (...args) => callback.call(this, ...args);
    __privateGet(this, _events)[event2].push(cb);
    return () => {
      __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2].filter(fn => fn !== cb);
    };
  }
  $destroy() {
    __privateGet(this, _instance).$destroy();
  }
};

_events = new WeakMap;

_instance = new WeakMap;

if ("function" == typeof HTMLElement) SvelteElement = class extends HTMLElement {
  constructor($$componentCtor, $$slots, use_shadow_dom) {
    super();
    __publicField(this, "$$ctor");
    __publicField(this, "$$s");
    __publicField(this, "$$c");
    __publicField(this, "$$cn", false);
    __publicField(this, "$$d", {});
    __publicField(this, "$$r", false);
    __publicField(this, "$$p_d", {});
    __publicField(this, "$$l", {});
    __publicField(this, "$$l_u", new Map);
    __publicField(this, "$$me");
    this.$$ctor = $$componentCtor;
    this.$$s = $$slots;
    if (use_shadow_dom) this.attachShadow({
      mode: "open"
    });
  }
  addEventListener(type, listener, options) {
    this.$$l[type] = this.$$l[type] || [];
    this.$$l[type].push(listener);
    if (this.$$c) {
      const unsub = this.$$c.$on(type, listener);
      this.$$l_u.set(listener, unsub);
    }
    super.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type, listener, options);
    if (this.$$c) {
      const unsub = this.$$l_u.get(listener);
      if (unsub) {
        unsub();
        this.$$l_u.delete(listener);
      }
    }
  }
  async connectedCallback() {
    this.$$cn = true;
    if (!this.$$c) {
      let create_slot = function(name) {
        return anchor => {
          const slot2 = document.createElement("slot");
          if ("default" !== name) slot2.name = name;
          append(anchor, slot2);
        };
      };
      await Promise.resolve();
      if (!this.$$cn || this.$$c) return;
      const $$slots = {}, existing_slots = get_custom_elements_slots(this);
      for (const name of this.$$s) if (name in existing_slots) if ("default" === name && !this.$$d.children) {
        this.$$d.children = create_slot(name);
        $$slots.default = true;
      } else $$slots[name] = create_slot(name);
      for (const attribute of this.attributes) {
        const name = this.$$g_p(attribute.name);
        if (!(name in this.$$d)) this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
      }
      for (const key2 in this.$$p_d) if (!(key2 in this.$$d) && void 0 !== this[key2]) {
        this.$$d[key2] = this[key2];
        delete this[key2];
      }
      this.$$c = createClassComponent({
        component: this.$$ctor,
        target: this.shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots,
          $$host: this
        }
      });
      this.$$me = effect_root(() => {
        render_effect(() => {
          var _a3;
          this.$$r = true;
          for (const key2 of object_keys(this.$$c)) {
            if (!(null == (_a3 = this.$$p_d[key2]) ? void 0 : _a3.reflect)) continue;
            this.$$d[key2] = this.$$c[key2];
            const attribute_value = get_custom_element_value(key2, this.$$d[key2], this.$$p_d, "toAttribute");
            if (null == attribute_value) this.removeAttribute(this.$$p_d[key2].attribute || key2); else this.setAttribute(this.$$p_d[key2].attribute || key2, attribute_value);
          }
          this.$$r = false;
        });
      });
      for (const type in this.$$l) for (const listener of this.$$l[type]) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      this.$$l = {};
    }
  }
  attributeChangedCallback(attr2, _oldValue, newValue) {
    var _a3;
    if (!this.$$r) {
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      null == (_a3 = this.$$c) || _a3.$set({
        [attr2]: this.$$d[attr2]
      });
    }
  }
  disconnectedCallback() {
    this.$$cn = false;
    Promise.resolve().then(() => {
      if (!this.$$cn && this.$$c) {
        this.$$c.$destroy();
        this.$$me();
        this.$$c = void 0;
      }
    });
  }
  $$g_p(attribute_name) {
    return object_keys(this.$$p_d).find(key2 => this.$$p_d[key2].attribute === attribute_name || !this.$$p_d[key2].attribute && key2.toLowerCase() === attribute_name) || attribute_name;
  }
};

function get_custom_element_value(prop2, value, props_definition, transform) {
  var _a3;
  const type = null == (_a3 = props_definition[prop2]) ? void 0 : _a3.type;
  value = "Boolean" === type && "boolean" != typeof value ? null != value : value;
  if (!transform || !props_definition[prop2]) return value; else if ("toAttribute" === transform) switch (type) {
   case "Object":
   case "Array":
    return null == value ? null : JSON.stringify(value);

   case "Boolean":
    return value ? "" : null;

   case "Number":
    return null == value ? null : value;

   default:
    return value;
  } else switch (type) {
   case "Object":
   case "Array":
    return value && JSON.parse(value);

   case "Boolean":
    return value;

   case "Number":
    return null != value ? +value : value;

   default:
    return value;
  }
}

function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(node => {
    result[node.slot || "default"] = true;
  });
  return result;
}

if (dev_fallback_default) {
  let throw_rune_error = function(rune) {
    if (!(rune in globalThis)) {
      let value;
      Object.defineProperty(globalThis, rune, {
        configurable: true,
        get: () => {
          if (void 0 !== value) return value;
          rune_outside_svelte(rune);
        },
        set: v => {
          value = v;
        }
      });
    }
  };
  throw_rune_error("$state");
  throw_rune_error("$effect");
  throw_rune_error("$derived");
  throw_rune_error("$inspect");
  throw_rune_error("$props");
  throw_rune_error("$bindable");
}

function onMount(fn) {
  if (null === component_context) lifecycle_outside_component("onMount");
  if (legacy_mode_flag && null !== component_context.l) init_update_callbacks(component_context).m.push(fn); else user_effect(() => {
    const cleanup = untrack(fn);
    if ("function" == typeof cleanup) return cleanup;
  });
}

function onDestroy(fn) {
  if (null === component_context) lifecycle_outside_component("onDestroy");
  onMount(() => () => untrack(fn));
}

function init_update_callbacks(context) {
  var _a3, l = context.l;
  return null != (_a3 = l.u) ? _a3 : l.u = {
    a: [],
    b: [],
    m: []
  };
}

function subscribe_to_store(store, run3, invalidate) {
  if (null == store) {
    run3(void 0);
    if (invalidate) invalidate(void 0);
    return noop;
  }
  const unsub = untrack(() => store.subscribe(run3, invalidate));
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}

var subscriber_queue = [];

function writable(value, start = noop) {
  let stop = null;
  const subscribers = new Set;
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) subscriber_queue[i][0](subscriber_queue[i + 1]);
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set2(fn(value));
  }
  return {
    set: set2,
    update: update2,
    subscribe: function subscribe(run3, invalidate = noop) {
      const subscriber = [ run3, invalidate ];
      subscribers.add(subscriber);
      if (1 === subscribers.size) stop = start(set2, update2) || noop;
      run3(value);
      return () => {
        subscribers.delete(subscriber);
        if (0 === subscribers.size && stop) {
          stop();
          stop = null;
        }
      };
    }
  };
}

function get2(store) {
  let value;
  subscribe_to_store(store, _ => value = _)();
  return value;
}

var currentFile = writable(""), maxDepth = writable(0), searchString = writable(""), tagInfo = writable({}), tagFolderSetting = writable(DEFAULT_SETTINGS), selectedTags = writable(), allViewItems = writable(), allViewItemsByLink = writable(), appliedFiles = writable(), v2expandedTags = writable(new Set), performHide = writable(0), pluginInstance = writable(void 0);

function unique(items) {
  return [ ...new Set([ ...items ]) ];
}

function trimSlash(src, keepStart = false, keepEnd = false) {
  const st = keepStart ? 0 : "/" == src[0] ? 1 : 0, end = keepEnd ? void 0 : src.endsWith("/") ? -1 : void 0;
  if (0 == st && null == end) return src; else return src.slice(st, end);
}

function trimPrefix(source2, prefix) {
  if (source2.startsWith(prefix)) return source2.substring(prefix.length); else return source2;
}

function ancestorToTags(ancestors) {
  return [ ...ancestors ].reduce((p, i) => "/" != i[0] ? [ ...p, i ] : [ ...p, p.pop() + "/" + i.substring(1) ], []);
}

function ancestorToLongestTag(ancestors) {
  return ancestors.reduceRight((a, e) => {
    var _a3;
    return !a ? [ e ] : (null == (_a3 = a[0]) ? void 0 : _a3.startsWith(e)) ? a : [ e, ...a ];
  }, []);
}

function isSpecialTag(tagSrc) {
  const tag2 = trimSlash(tagSrc);
  return "_untagged" == tag2 || tag2 in tagDispDict;
}

var tagDispAlternativeDict = {};

tagInfo.subscribe(tagInfo2 => {
  tagDispAlternativeDict = {
    ...tagDispDict
  };
  if (null == tagInfo2) return;
  const items = Object.entries(tagInfo2);
  for (const [key2, info] of items) if (null == info ? void 0 : info.alt) tagDispAlternativeDict[key2] = info.alt;
});

function renderSpecialTag(tagSrc) {
  const tag2 = trimSlash(tagSrc);
  return tag2 in tagDispAlternativeDict ? tagDispAlternativeDict[tag2] : tagSrc;
}

function secondsToFreshness(totalAsMSec) {
  const totalAsSec = ~~(totalAsMSec / 1e3), totalSec = ~~(totalAsSec * (totalAsSec / Math.abs(totalAsSec)));
  if (totalSec < EPOCH_HOUR) return FRESHNESS_1;
  if (totalSec < 6 * EPOCH_HOUR) return FRESHNESS_2;
  if (totalSec < 3 * EPOCH_DAY) return FRESHNESS_3;
  if (totalSec < 7 * EPOCH_DAY) return FRESHNESS_4; else return FRESHNESS_5;
}

var queues = [];

function waitForRequestAnimationFrame() {
  return new Promise(res => requestAnimationFrame(() => res()));
}

function delay(num) {
  return new Promise(res => setTimeout(() => res(), num || 5));
}

function nextTick() {
  return new Promise(res => setTimeout(() => res(), 0));
}

var waits = [ nextTick, delay, nextTick, delay, delay, nextTick ], waitIdx = 0, pumping = false, startContinuousProcessing = Date.now();

async function pump() {
  if (!pumping) try {
    pumping = true;
    for (;;) {
      const proc = queues.shift();
      if (proc) {
        proc();
        if (Date.now() - startContinuousProcessing > 120) {
          const w = waits[waitIdx];
          waitIdx = (waitIdx + 1) % waits.length;
          await w();
          startContinuousProcessing = Date.now();
        }
      } else break;
    }
  } finally {
    pumping = false;
  }
}

var doEvents = () => new Promise(res => {
  queues.push(() => {
    res();
  });
  pump();
});

function compare(x, y) {
  return `${x || ""}`.localeCompare(y, void 0, {
    numeric: true
  });
}

function getTagName(tagName, subtreePrefix, tagInfo2, invert) {
  if (null == tagInfo2) return tagName;
  const prefix = -1 == invert ? "ï¿¿" : "", unpinned = 1 == invert ? "ï¿¿" : "";
  if (tagName in tagInfo2 && tagInfo2[tagName]) if ("key" in tagInfo2[tagName]) return `${prefix}_${subtreePrefix}_-${tagInfo2[tagName].key}__${tagName}`;
  return `${prefix}_${subtreePrefix}_${unpinned}_${tagName}`;
}

function removeIntermediatePath(paths) {
  const passed = [];
  for (const v of paths) {
    const last = passed.pop();
    if (void 0 !== last) if (!(trimTrailingSlash(v.toLowerCase()) + "/").startsWith(trimTrailingSlash(last.toLowerCase()) + "/")) passed.push(last);
    passed.push(v);
  }
  return passed.reverse();
}

function getTagMark(tagInfo2) {
  if (!tagInfo2) return "";
  if ("key" in tagInfo2) if ("mark" in tagInfo2 && "" != tagInfo2.mark) return tagInfo2.mark; else return "ðŸ“Œ"; else if ("mark" in tagInfo2 && "" != tagInfo2.mark) return tagInfo2.mark; else return "";
}

function escapeStringToHTML(str) {
  if (!str) return ""; else return str.replace(/[<>&"'`]/g, match => ({
    "<": "&lt;",
    ">": "&gt;",
    "&": "&amp;",
    '"': "&quot;",
    "'": "&#39;",
    "`": "&#x60;"
  }[match]));
}

var V2FI_IDX_TAG = 0, V2FI_IDX_TAGNAME = 1, V2FI_IDX_TAGDISP = 2, V2FI_IDX_CHILDREN = 3;

function selectCompareMethodTags(settings, tagInfo2) {
  const _tagInfo = tagInfo2, invert = settings.sortTypeTag.contains("_DESC") ? -1 : 1, subTreeChar = {
    [-1]: "ô¿¿",
    [1]: "_"
  }, sortByName = (a, b) => {
    const isASubTree = "" == a[V2FI_IDX_TAGDISP][0], isBSubTree = "" == b[V2FI_IDX_TAGDISP][0], aName = a[V2FI_IDX_TAGNAME], bName = b[V2FI_IDX_TAGNAME], aPrefix = isASubTree ? subTreeChar[invert] : "", bPrefix = isBSubTree ? subTreeChar[invert] : "";
    return compare(getTagName(aName, aPrefix, settings.useTagInfo ? _tagInfo : void 0, invert), getTagName(bName, bPrefix, settings.useTagInfo ? _tagInfo : void 0, invert)) * invert;
  };
  switch (settings.sortTypeTag) {
   case "ITEMS_ASC":
   case "ITEMS_DESC":
    return (a, b) => {
      const aName = a[V2FI_IDX_TAGNAME], bName = b[V2FI_IDX_TAGNAME], aCount = a[V2FI_IDX_CHILDREN].length - (settings.useTagInfo && aName in _tagInfo && "key" in _tagInfo[aName] ? 1e5 * invert : 0), bCount = b[V2FI_IDX_CHILDREN].length - (settings.useTagInfo && bName in _tagInfo && "key" in _tagInfo[bName] ? 1e5 * invert : 0);
      if (aCount == bCount) return sortByName(a, b); else return (aCount - bCount) * invert;
    };

   case "NAME_ASC":
   case "NAME_DESC":
    return sortByName;

   default:
    console.warn("Compare method (tags) corrupted");
    return (a, b) => {
      const isASubTree = "" == a[V2FI_IDX_TAGDISP][0], isBSubTree = "" == b[V2FI_IDX_TAGDISP][0], aName = a[V2FI_IDX_TAGNAME], bName = b[V2FI_IDX_TAGNAME];
      return compare((isASubTree ? subTreeChar[invert] : "") + aName, (isBSubTree ? subTreeChar[invert] : "") + bName) * invert;
    };
  }
}

function uniqueCaseIntensive(pieces) {
  const delMap = new Set, ret = [];
  for (const piece of pieces) if (!delMap.has(piece.toLowerCase())) {
    ret.push(piece);
    delMap.add(piece.toLowerCase());
  }
  return ret;
}

function _sorterTagLength(a, b, invert) {
  const diff = a.split("/").length - b.split("/").length;
  if (0 != diff) return diff * (invert ? -1 : 1); else return (a.length - b.length) * (invert ? -1 : 1);
}

function getExtraTags(tags, trail, reduceNestedParent) {
  let tagsLeft = uniqueCaseIntensive(tags), removeTrailItems = [];
  if (reduceNestedParent) removeTrailItems = trail.sort((a, b) => _sorterTagLength(a, b, true)); else removeTrailItems = removeIntermediatePath(trail);
  for (const t of removeTrailItems) {
    const trimLength = t.endsWith("/") ? t.length : t.length;
    if (reduceNestedParent) tagsLeft = tagsLeft.map(e => (e + "/").toLowerCase().startsWith(t.toLowerCase()) ? e.substring(trimLength) : e); else {
      const f = tagsLeft.findIndex(e => (e + "/").toLowerCase().startsWith(t.toLowerCase()));
      if (-1 !== f) tagsLeft[f] = tagsLeft[f].substring(trimLength);
    }
  }
  return tagsLeft.filter(e => "" != e.trim());
}

function trimTrailingSlash(src) {
  return trimSlash(src, true, false);
}

function joinPartialPath(path) {
  return path.reduce((p, c) => c.endsWith("/") && p.length > 0 ? [ c + p[0], ...p.slice(1) ] : [ c, ...p ], []);
}

function pathMatch(haystackLC, needleLC) {
  if (haystackLC == needleLC) return true;
  if ("/" == needleLC[needleLC.length - 1]) if (0 === (haystackLC + "/").indexOf(needleLC)) return true;
  return false;
}

function parseTagName(thisName, _tagInfo) {
  let tagNameDisp = [ "" ];
  const names = thisName.split("/").filter(e => "" != e.trim());
  let inSubTree = false, tagName = "";
  if (names.length > 1) {
    tagName = `${names[names.length - 1]}`;
    inSubTree = true;
  } else tagName = thisName;
  if (tagName.endsWith("/")) tagName = tagName.substring(0, tagName.length - 1);
  const tagMark = getTagMark(tagName in _tagInfo ? _tagInfo[tagName] : void 0);
  tagNameDisp = [ `${tagMark}${renderSpecialTag(tagName)}` ];
  if (inSubTree) tagNameDisp = [ `${tagMark}`, `${renderSpecialTag(tagName)}` ];
  return [ tagName, tagNameDisp ];
}

function parseAllForwardReference(metaCache, filename, passed) {
  var _a3;
  return unique(Object.keys(null != (_a3 = null == metaCache ? void 0 : metaCache[filename]) ? _a3 : {}).filter(e => !passed.contains(e)));
}

function parseAllReverseReference(metaCache, filename, passed) {
  return unique(Object.entries(metaCache).filter(([, links]) => filename in links).map(([name]) => name).filter(e => !passed.contains(e)));
}

function parseAllReference(metaCache, filename, conf) {
  var _a3, _b3;
  let linked = [ ...!(null == (_a3 = null == conf ? void 0 : conf.outgoing) ? void 0 : _a3.enabled) ? [] : parseAllForwardReference(metaCache, filename, []), ...!(null == (_b3 = null == conf ? void 0 : conf.incoming) ? void 0 : _b3.enabled) ? [] : parseAllReverseReference(metaCache, filename, []) ];
  if (0 != linked.length) linked = unique([ filename, ...linked ]);
  return linked;
}

function fileCacheToCompare(cache) {
  if (!cache) return ""; else return {
    l: cache.links,
    t: cache.tags
  };
}

var allViewItemsMap = new Map;

allViewItemsByLink.subscribe(e => {
  updateItemsLinkMap(e);
});

function updateItemsLinkMap(e) {
  allViewItemsMap.clear();
  if (e) e.forEach(item => allViewItemsMap.set(item.path, item));
}

function getViewItemFromPath(path) {
  return allViewItemsMap.get(path);
}

function getAllLinksRecursive(item, trail) {
  const leftLinks = item.links.filter(e => !trail.contains(e)), allChildLinks = leftLinks.flatMap(itemName => {
    const item2 = getViewItemFromPath(itemName);
    if (!item2) return []; else return getAllLinksRecursive(item2, [ ...trail, itemName ]);
  });
  return unique([ ...leftLinks, ...allChildLinks ]);
}

var waitingProcess = new Map, runningProcess = new Set;

async function scheduleOnceIfDuplicated(key2, proc) {
  if (!runningProcess.has(key2)) try {
    runningProcess.add(key2);
    await delay(3);
    if (waitingProcess.has(key2)) {
      const nextProc = waitingProcess.get(key2);
      waitingProcess.delete(key2);
      runningProcess.delete(key2);
      return scheduleOnceIfDuplicated(key2, nextProc);
    } else await proc();
  } finally {
    runningProcess.delete(key2);
  } else waitingProcess.set(key2, proc);
}

function isSameAny(a, b) {
  if (typeof a != typeof b) return false;
  switch (typeof a) {
   case "string":
   case "number":
   case "bigint":
   case "boolean":
   case "symbol":
   case "function":
   case "undefined":
    return a == b;

   case "object":
    if (a === b) return true;
    if (a instanceof Map || a instanceof Set) {
      if (a.size != b.size) return false;
      const v = [ ...a ], w = [ ...b ];
      for (let i = 0; i < v.length; i++) if (v[i] != w[i]) return false;
      return true;
    }
    if (Array.isArray(a)) {
      for (let i = 0; i < a.length; i++) if (!isSameAny(a[i], b[i])) return false;
      return true;
    }
    {
      const x = Object.values(a), y = Object.values(b);
      if (x.length != y.length) return false;
      for (let i = 0; i < x.length; i++) if (!isSameAny(x[i], y[i])) return false;
      return true;
    }

   default:
    return false;
  }
}

var _a2, _b2, _c, import_obsidian2 = require("obsidian"), PUBLIC_VERSION = "5";

if ("undefined" != typeof window) (null != (_c = (_b2 = null != (_a2 = window.__svelte) ? _a2 : window.__svelte = {}).v) ? _c : _b2.v = new Set).add(PUBLIC_VERSION);

var import_obsidian = require("obsidian"), root = from_html('<div class="markdownBody svelte-164rifk" style="min-height: 1em;"></div>'), $$css = {
  hash: "svelte-164rifk",
  code: ".markdownBody.svelte-164rifk {user-select:text;-webkit-user-select:text;}"
};

function ScrollViewMarkdownComponent($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css);
  let file = prop($$props, "file", 19, () => ({
    path: ""
  })), el = state(void 0), renderedContent = state("");
  function onAppearing(_) {
    if (file().content && get(el) && get(renderedContent) != file().content) {
      import_obsidian.MarkdownRenderer.render($$props.plugin.app, file().content, get(el), file().path, $$props.plugin);
      set(renderedContent, file().content, true);
    }
  }
  onMount(() => {
    if (get(el) && $$props.observer) {
      $$props.observer.observe(get(el));
      get(el).addEventListener("appearing", onAppearing);
    }
  });
  onDestroy(() => {
    if (get(el) && $$props.observer) {
      $$props.observer.unobserve(get(el));
      get(el).removeEventListener("appearing", onAppearing);
    }
  });
  user_effect(() => {
    if (get(renderedContent) && file() && file().content && get(el) && get(renderedContent) != file().content) {
      get(el).style.minHeight = `${get(el).clientHeight}px`;
      get(el).innerHTML = "";
      import_obsidian.MarkdownRenderer.render($$props.plugin.app, file().content, get(el), file().path, $$props.plugin);
      set(renderedContent, file().content, true);
      get(el).style.minHeight = "20px";
    }
  });
  var div = root();
  bind_this(div, $$value => set(el, $$value), () => get(el));
  append($$anchor, div);
  pop();
}

var root_1 = from_html('<div class="file svelte-5gvkrt"><div class="header svelte-5gvkrt"><span> </span> <span class="path svelte-5gvkrt"> </span></div> <!> <hr class="svelte-5gvkrt"/></div>'), root2 = from_html('<div class="x"><div class="header svelte-5gvkrt"> </div> <hr class="svelte-5gvkrt"/> <!></div>'), $$css2 = {
  hash: "svelte-5gvkrt",
  code: ".header.svelte-5gvkrt {background-color:var(--background-secondary-alt);position:sticky;top:0;color:var(--text-normal);margin-bottom:8px;}.file.svelte-5gvkrt {cursor:pointer;}.path.svelte-5gvkrt {font-size:75%;}hr.svelte-5gvkrt {margin:8px auto;}"
};

function ScrollViewComponent($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css2);
  const [$$stores, $$cleanup] = setup_stores();
  let store = prop($$props, "store", 19, () => writable({
    files: [],
    title: "",
    tagPath: ""
  }));
  const _state = user_derived(() => store_get(store(), "$store", $$stores));
  let files = user_derived(() => get(_state).files);
  const tagPath = user_derived(() => get(_state).tagPath.split(", ").map(e => "#" + trimTrailingSlash(e).split("/").map(e2 => renderSpecialTag(e2.trim())).join("/")).join(", "));
  let scrollEl = state(void 0), observer = state(void 0);
  const onAppearing = new CustomEvent("appearing", {
    detail: {}
  });
  user_effect(() => {
    const options = {
      root: get(scrollEl),
      rootMargin: "10px",
      threshold: 0
    };
    set(observer, new IntersectionObserver(entries => {
      for (const entry of entries) if (entry.isIntersecting) entry.target.dispatchEvent(onAppearing);
    }, options), true);
  });
  onDestroy(() => {
    null === get(observer) || void 0 === get(observer) || get(observer).disconnect();
  });
  var div = root2(), div_1 = child(div), text2 = child(div_1);
  reset(div_1);
  each(sibling(div_1, 4), 17, () => get(files), index, ($$anchor2, file) => {
    var div_2 = root_1();
    div_2.__click = evt => function handleOpenFile(e, file) {
      $$props.openfile(file.path, false);
      e.preventDefault();
    }(evt, get(file));
    var div_3 = child(div_2), span = child(div_3), text_1 = child(span, true);
    reset(span);
    var span_1 = sibling(span, 2), text_2 = child(span_1);
    reset(span_1);
    reset(div_3);
    ScrollViewMarkdownComponent(sibling(div_3, 2), {
      get file() {
        return get(file);
      },
      get observer() {
        return get(observer);
      },
      get plugin() {
        return $$props.plugin;
      }
    });
    next(2);
    reset(div_2);
    bind_this(div_2, $$value => set(scrollEl, $$value), () => get(scrollEl));
    template_effect(() => {
      var _a3;
      set_text(text_1, get(file).title);
      set_text(text_2, `(${null != (_a3 = get(file).path) ? _a3 : ""})`);
    });
    append($$anchor2, div_2);
  });
  reset(div);
  template_effect(() => {
    var _a3;
    return set_text(text2, `Files with ${null != (_a3 = get(tagPath)) ? _a3 : ""}`);
  });
  append($$anchor, div);
  pop();
  $$cleanup();
}

delegate([ "click" ]);

var ScrollView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.icon = "sheets-in-box";
    this.state = {
      files: [],
      title: "",
      tagPath: ""
    };
    this.title = "";
    this.navigation = true;
    this.plugin = plugin;
    this.store = writable({
      files: [],
      title: "",
      tagPath: ""
    });
  }
  getIcon() {
    return "sheets-in-box";
  }
  getViewType() {
    return VIEW_TYPE_SCROLL;
  }
  getDisplayText() {
    return this.state.tagPath || "Tags scroll";
  }
  async setFile(filenames) {
    this.state = {
      ...this.state,
      files: filenames
    };
    await this.updateView();
  }
  async setState(state2, result) {
    this.state = {
      ...state2
    };
    this.title = state2.title;
    await this.updateView();
  }
  getState() {
    return this.state;
  }
  isFileOpened(path) {
    return this.state.files.some(e => e.path == path);
  }
  getScrollViewState() {
    return this.state;
  }
  async updateView() {
    const items = [];
    for (const item of this.state.files) if (item.content) items.push(item); else {
      const f = this.app.vault.getAbstractFileByPath(item.path);
      if (null == f || !(f instanceof import_obsidian2.TFile)) {
        console.log(`File not found:${item.path}`);
        items.push(item);
        continue;
      }
      const title = this.plugin.getFileTitle(f), w = await this.app.vault.read(f);
      await doEvents();
      item.content = w;
      item.title = title;
      items.push(item);
    }
    this.state = {
      ...this.state,
      files: [ ...items ]
    };
    this.store.set(this.state);
  }
  async onOpen() {
    const app = mount(ScrollViewComponent, {
      target: this.contentEl,
      props: {
        store: this.store,
        openfile: this.plugin.focusFile,
        plugin: this.plugin
      }
    });
    this.component = app;
    return await Promise.resolve();
  }
  async onClose() {
    if (this.component) {
      await unmount(this.component);
      this.component = void 0;
    }
    return await Promise.resolve();
  }
}, import_obsidian6 = require("obsidian");

function performSortExactFirst(_items, children, leftOverItems) {
  const childrenPathsArr = children.map(e => e[V2FI_IDX_CHILDREN].map(ee => ee.path)).flat(), childrenPaths = new Set(childrenPathsArr), exactHerePaths = new Set(_items.map(e => e.path));
  childrenPaths.forEach(path => exactHerePaths.delete(path));
  return [ ...[ ...leftOverItems ].sort((a, b) => (exactHerePaths.has(a.path) ? -1 : 0) + (exactHerePaths.has(b.path) ? 1 : 0)) ];
}

function delay2() {
  return new Promise(res => setTimeout(() => res(), 5));
}

function nextTick2() {
  return new Promise(res => setTimeout(() => res(), 0));
}

var delays = [ nextTick2, delay2, nextTick2, waitForRequestAnimationFrame ], delayIdx = 0;

async function collectChildren(previousTrail, tags, _tagInfo, _items) {
  const previousTrailLC = previousTrail.toLowerCase(), children = [], tagPerItem = new Map, lowercaseMap = new Map;
  for (const item of _items) item.tags.forEach(itemTag => {
    var _a3;
    const tagLc = null != (_a3 = lowercaseMap.get(itemTag)) ? _a3 : lowercaseMap.set(itemTag, itemTag.toLowerCase()).get(itemTag);
    if (!tagPerItem.has(tagLc)) tagPerItem.set(tagLc, []);
    tagPerItem.get(tagLc).push(item);
  });
  for (const tag2 of tags) {
    const tagLC = tag2.toLowerCase(), tagNestedLC = trimPrefix(tagLC, previousTrailLC), items = [];
    for (const [itemTag, tempItems] of tagPerItem) if (pathMatch(itemTag, tagLC)) items.push(...tempItems); else if (pathMatch(itemTag, tagNestedLC)) items.push(...tempItems);
    children.push([ tag2, ...parseTagName(tag2, _tagInfo), [ ...new Set(items) ] ]);
    delayIdx++;
    delayIdx %= 4;
    await delays[delayIdx]();
  }
  return children;
}

async function collectTreeChildren({key: key2, expandLimit, depth, tags, trailLower, _setting, isMainTree, isSuppressibleLevel, viewType, previousTrail, _tagInfo, _items, linkedItems, isRoot, sortFunc}) {
  let suppressLevels = [], children = [];
  if (expandLimit && depth >= expandLimit) {
    children = [];
    suppressLevels = getExtraTags(tags, trailLower, _setting.reduceNestedParent);
  } else if (!isMainTree) children = []; else if (isSuppressibleLevel) {
    children = [];
    suppressLevels = getExtraTags(tags, trailLower, _setting.reduceNestedParent);
  } else {
    let wChildren = [];
    if ("tags" == viewType) wChildren = await collectChildren(previousTrail, tags, _tagInfo, _items); else if ("links" == viewType) wChildren = tags.map(tag2 => {
      var _a3;
      const selfInfo = getViewItemFromPath(tag2), dispName = !selfInfo ? tag2 : selfInfo.displayName;
      return [ tag2, dispName, [ dispName ], null != (_a3 = linkedItems.get(tag2)) ? _a3 : [] ];
    });
    if ("tags" == viewType) {
      if (_setting.mergeRedundantCombination) {
        const out = [], isShown = new Set;
        for (const [tag2, tagName, tagsDisp, items] of wChildren) {
          const list = [];
          for (const v of items) if (!isShown.has(v.path)) {
            list.push(v);
            isShown.add(v.path);
          }
          if (0 != list.length) out.push([ tag2, tagName, tagsDisp, list ]);
        }
        wChildren = out;
      }
      if (isMainTree && isRoot) {
        const archiveTags = _setting.archiveTags.toLowerCase().replace(/[\n ]/g, "").split(",");
        wChildren = wChildren.map(e => archiveTags.some(aTag => `${aTag}//`.startsWith(e[V2FI_IDX_TAG].toLowerCase() + "/")) ? e : [ e[V2FI_IDX_TAG], e[V2FI_IDX_TAGNAME], e[V2FI_IDX_TAGDISP], e[V2FI_IDX_CHILDREN].filter(items => !items.tags.some(e2 => archiveTags.contains(e2.toLowerCase()))) ]).filter(child2 => 0 != child2[V2FI_IDX_CHILDREN].length);
      }
    }
    wChildren = wChildren.sort(sortFunc);
    children = wChildren;
  }
  return {
    suppressLevels,
    children
  };
}

var root3 = from_html("<div><!></div>");

function OnDemandRender($$anchor, $$props) {
  push($$props, true);
  let cssClass = prop($$props, "cssClass", 3, ""), isVisible = prop($$props, "isVisible", 15, false), hidingScheduled = state(false);
  const {observe, unobserve} = getContext("observer");
  function setIsVisible(visibility) {
    if (isVisible() != visibility) if (visibility) isVisible(visibility);
    set(hidingScheduled, !visibility);
  }
  onMount(() => {
    performHide.subscribe(() => {
      if (get(hidingScheduled)) {
        isVisible(false);
        set(hidingScheduled, false);
      }
    });
  });
  onDestroy(() => {
    if (get(_el)) unobserve(get(_el));
  });
  let _el = state(void 0), el = state(void 0);
  user_effect(() => {
    if (get(_el) != get(el)) {
      if (get(_el)) unobserve(get(_el));
      set(_el, get(el), true);
      if (get(el)) observe(get(el), setIsVisible);
    }
  });
  var div = root3();
  snippet(child(div), () => {
    var _a3;
    return null != (_a3 = $$props.children) ? _a3 : noop;
  }, () => ({
    isVisible: isVisible()
  }));
  reset(div);
  bind_this(div, $$value => set(el, $$value), () => get(el));
  template_effect(() => set_class(div, 1, clsx2(cssClass())));
  append($$anchor, div);
  pop();
}

var root_2 = from_html('<div class="tf-taglist"><!></div>'), root_12 = from_html('<div><div class="tree-item-inner nav-file-title-content lsl-f"> </div> <!></div>');

function V2TreeItemComponent($$anchor, $$props) {
  push($$props, true);
  const $pluginInstance = () => store_get(pluginInstance, "$pluginInstance", $$stores), [$$stores, $$cleanup] = setup_stores(), _setting = user_derived(() => store_get(tagFolderSetting, "$tagFolderSetting", $$stores)), _currentActiveFilePath = user_derived(() => store_get(currentFile, "$currentFile", $$stores));
  let isActive = user_derived(() => $$props.item.path == get(_currentActiveFilePath)), isItemVisible = state(false);
  const tagsLeft = user_derived(() => get(isItemVisible) ? uniqueCaseIntensive([ ...getExtraTags($$props.item.tags, [ ...$$props.trail ], get(_setting).reduceNestedParent), ...$$props.item.extraTags ].map(e => trimSlash(e, false, true)).map(e => e.split("/").map(ee => renderSpecialTag(ee)).join("/")).filter(e => "" != e)) : []), extraTagsHtml = user_derived(() => `${get(tagsLeft).map(e => `<span class="tf-tag">${escapeStringToHTML(e)}</span>`).join("")}`), draggable = user_derived(() => !get(_setting).disableDragging), app = user_derived(() => null === $pluginInstance() || void 0 === $pluginInstance() ? void 0 : $pluginInstance().app), dm = user_derived(() => null === get(app) || void 0 === get(app) ? void 0 : get(app).dragManager);
  function dragStartFile(args) {
    if (!get(draggable)) return;
    const file = get(app).vault.getAbstractFileByPath($$props.item.path), param = get(dm).dragFile(args, file);
    if (param) return get(dm).onDragStart(args, param);
  }
  {
    const children = ($$anchor2, $$arg0) => {
      let isVisible = () => null == $$arg0 ? void 0 : $$arg0().isVisible;
      var div = root_12();
      let classes;
      div.__click = evt => $$props.openFile($$props.item.path, evt.metaKey || evt.ctrlKey);
      div.__mouseover = e => {
        (function handleMouseover(e, path) {
          $$props.hoverPreview(e, path);
        })(e, $$props.item.path);
      };
      div.__contextmenu = evt => $$props.showMenu(evt, $$props.trail, void 0, [ $$props.item ]);
      var div_1 = child(div), text2 = child(div_1, true);
      reset(div_1);
      var node = sibling(div_1, 2), consequent = $$anchor3 => {
        var div_2 = root_2();
        html(child(div_2), () => get(extraTagsHtml));
        reset(div_2);
        append($$anchor3, div_2);
      };
      if_block(node, $$render => {
        if (isVisible()) $$render(consequent);
      });
      reset(div);
      template_effect(() => {
        classes = set_class(div, 1, "tree-item-self is-clickable nav-file-title", null, classes, {
          "is-active": get(isActive)
        });
        set_attribute2(div, "draggable", get(draggable));
        set_attribute2(div, "data-path", $$props.item.path);
        set_text(text2, isVisible() ? $$props.item.displayName : "");
      });
      event("dragstart", div, dragStartFile);
      event("focus", div, () => {});
      append($$anchor2, div);
    };
    OnDemandRender($$anchor, {
      cssClass: "tree-item nav-file",
      get isVisible() {
        return get(isItemVisible);
      },
      set isVisible($$value) {
        set(isItemVisible, $$value, true);
      },
      children,
      $$slots: {
        default: true
      }
    });
  }
  pop();
  $$cleanup();
}

delegate([ "click", "mouseover", "contextmenu" ]);

var root_22 = from_html('<div class="tree-item-self nav-folder-title"><div class="tree-item-inner nav-folder-title-content"> </div></div>'), root_6 = from_svg('<svg class="svg-icon"></svg>'), root_7 = from_html('<div class="tagfolder-titletagname"><!></div>'), root_8 = from_html('<div class="tagfolder-titletagname">...</div>'), root_4 = from_html('<div><!></div> <div class="tree-item-inner nav-folder-title-content lsl-f"><!> <div class="tagfolder-quantity itemscount"><span class="itemscount"> </span></div></div>', 1), root_10 = from_html("<!> <!>", 1), root_15 = from_html('<div class="tree-item-children nav-folder-children"><!></div>'), root4 = from_html("<div><!> <!></div>");

function V2TreeFolderComponent_1($$anchor, $$props) {
  push($$props, true);
  const [$$stores, $$cleanup] = setup_stores();
  var _a3, _b3, _c2;
  let viewType = prop($$props, "viewType", 3, "tags"), thisName = prop($$props, "thisName", 3, ""), items = prop($$props, "items", 19, () => []), tagName = prop($$props, "tagName", 11, ""), tagNameDisp = prop($$props, "tagNameDisp", 27, () => proxy([])), trail = prop($$props, "trail", 19, () => []), depth = prop($$props, "depth", 3, 1), folderIcon = prop($$props, "folderIcon", 3, ""), headerTitle = prop($$props, "headerTitle", 3, ""), _setting = user_derived(() => store_get(tagFolderSetting, "$tagFolderSetting", $$stores));
  const expandLimit = user_derived(() => !get(_setting).expandLimit ? 0 : "links" == viewType() ? get(_setting).expandLimit + 1 : get(_setting).expandLimit), _tagInfo = user_derived(() => store_get(tagInfo, "$tagInfo", $$stores)), _currentActiveFilePath = user_derived(() => store_get(currentFile, "$currentFile", $$stores));
  function shouldResponsibleFor(evt) {
    if (evt.target instanceof Element && evt.target.matchParent(".is-clickable.mod-collapsible.nav-folder-title")) return true; else return false;
  }
  function toggleFolder(evt) {
    evt.stopPropagation();
    if (shouldResponsibleFor(evt)) {
      evt.preventDefault();
      if (get(_setting).useMultiPaneList) selectedTags.set(trail());
      v2expandedTags.update(evt2 => {
        if (evt2.has(get(trailKey))) evt2.delete(get(trailKey)); else evt2.add(get(trailKey));
        return evt2;
      });
    }
  }
  let _lastParam, suppressLevels = state(proxy([])), children = state(proxy([])), isUpdating = state(false);
  const viewContextID = `${null !== (_a3 = getContext("viewID")) && void 0 !== _a3 ? _a3 : ""}`;
  let isFolderVisible = state(false);
  function splitArrayToBatch(items2) {
    const ret = [];
    if (items2 && items2.length > 0) {
      const applyItems = [ ...items2 ];
      do {
        const batch = applyItems.splice(0, 80);
        if (0 == batch.length) break;
        ret.push(batch);
        if (batch.length < 80) break;
      } while (applyItems.length > 0);
    }
    return ret;
  }
  function dragStartFiles(args) {
    if (!get(draggable)) return;
    const files = get(_items).map(e => get(app).vault.getAbstractFileByPath(e.path)), param = get(dm).dragFiles(args, files);
    if (param) return get(dm).onDragStart(args, param);
  }
  function dragStartName(args) {
    if (!get(draggable)) return;
    if ("links" == viewType()) return function dragStartFile(args) {
      if (!get(draggable)) return;
      const file = get(app).vault.getAbstractFileByPath(get(filename)), param = get(dm).dragFile(args, file);
      if (param) return get(dm).onDragStart(args, param); else return;
    }(args);
    const expandedTags = [ ...ancestorToLongestTag(ancestorToTags(joinPartialPath(removeIntermediatePath([ ...trail(), ...get(suppressLevels) ])))) ].map(e => trimTrailingSlash(e)).map(e => e.split("/").filter(ee => !isSpecialTag(ee)).join("/")).filter(e => "" != e).map(e => "#" + e).join(" ").trim();
    args.dataTransfer.setData("text/plain", expandedTags);
    args.dataTransfer.setData("Text", expandedTags);
    args.title = expandedTags;
    args.draggable = true;
    get(dm).onDragStart(args, args);
  }
  function handleOpenItem(evt) {
    if ("tags" != viewType()) {
      evt.preventDefault();
      evt.stopPropagation();
      $$props.openFile(get(filename), evt.metaKey || evt.ctrlKey);
    }
  }
  const filename = user_derived(() => "tags" == viewType() ? "" : thisName().substring(thisName().indexOf(":") + 1)), thisInfo = user_derived(() => "links" != viewType() ? void 0 : getViewItemFromPath(thisName())), thisLinks = user_derived(() => "links" != viewType() ? [] : (null !== (_b3 = null === get(thisInfo) || void 0 === get(thisInfo) ? void 0 : get(thisInfo).links) && void 0 !== _b3 ? _b3 : []).map(e => `${e}`)), thisNameLC = user_derived(() => thisName().toLowerCase()), tagNameLC = user_derived(() => tagName().toLowerCase()), trailKey = user_derived(() => trail().join("*")), trailLower = user_derived(() => trail().map(e => e.toLowerCase())), collapsed = user_derived(() => !$$props.isRoot && !store_get(v2expandedTags, "$v2expandedTags", $$stores).has(get(trailKey))), inMiddleOfTagHierarchy = user_derived(() => trail().length >= 1 && trail()[trail().length - 1].endsWith("/")), previousTrail = user_derived(() => get(inMiddleOfTagHierarchy) ? trail()[trail().length - 1] : ""), lastTrailTagLC = user_derived(() => trimTrailingSlash(get(previousTrail)).toLowerCase()), _items = user_derived(items), tagsAllCI = user_derived(() => uniqueCaseIntensive(get(_items).flatMap(e => e.tags))), tagsAllLower = user_derived(() => get(tagsAllCI).map(e => e.toLowerCase())), isInDedicatedTag = user_derived(() => get(inMiddleOfTagHierarchy) && !get(tagsAllLower).contains(get(lastTrailTagLC))), isMixedDedicatedTag = user_derived(() => get(inMiddleOfTagHierarchy)), displayTagCandidates = user_derived(() => {
    let tagsAll = [];
    if ("links" == viewType()) {
      if (!$$props.isRoot) if (!get(_setting).linkShowOnlyFDR) tagsAll = get(thisInfo) ? getAllLinksRecursive(get(thisInfo), [ ...trail() ]) : [ ...get(thisLinks) ]; else tagsAll = [ ...get(thisLinks) ]; else tagsAll = unique(get(_items).flatMap(e => e.links));
      if (!$$props.isRoot || get(_setting).expandUntaggedToRoot) tagsAll = tagsAll.filter(e => "_unlinked" != e);
      tagsAll = tagsAll.filter(e => !trail().contains(e));
    } else {
      tagsAll = uniqueCaseIntensive(get(_items).flatMap(e => e.tags));
      if (!$$props.isRoot || get(_setting).expandUntaggedToRoot) tagsAll = tagsAll.filter(e => "_untagged" != e);
    }
    return tagsAll;
  }), tagsExceptAlreadyShown = user_derived(() => "tags" != viewType() ? [] : get(displayTagCandidates).filter(tag2 => trail().every(trail2 => trimTrailingSlash(tag2.toLowerCase()) !== trimTrailingSlash(trail2.toLowerCase())))), passedTagWithoutThis = user_derived(() => {
    const trimSlashedThisNameLC = "/" + trimSlash(thisName()).toLowerCase();
    return get(tagsExceptAlreadyShown).filter(tag2 => {
      const lc = tag2.toLowerCase();
      return lc != get(thisNameLC) && lc != get(tagNameLC);
    }).filter(tag2 => !tag2.toLowerCase().endsWith(trimSlashedThisNameLC));
  }), escapedPreviousTrail = user_derived(() => !get(isMixedDedicatedTag) ? get(previousTrail) : get(previousTrail).split("/").join("*")), sparseIntermediateTags = user_derived(() => {
    const t1 = !get(isInDedicatedTag) ? get(passedTagWithoutThis) : get(passedTagWithoutThis).filter(e => (e + "/").startsWith(get(previousTrail)));
    if (!get(isInDedicatedTag)) return t1; else return t1.map(e => (e + "/").startsWith(get(previousTrail)) ? get(escapedPreviousTrail) + e.substring(get(previousTrail).length) : e);
  }), tagsPhaseX1 = user_derived(() => get(sparseIntermediateTags)), $$d = user_derived(() => {
    let isSuppressibleLevel2 = false, existTags = get(tagsPhaseX1), existTagsFiltered1 = [];
    if (!get(_setting).doNotSimplifyTags && "links" != viewType()) if (1 == get(_items).length) {
      existTagsFiltered1 = existTags;
      isSuppressibleLevel2 = true;
    } else if (1 == uniqueCaseIntensive(get(_items).map(e => [ ...e.tags ].sort().join("**"))).length) {
      isSuppressibleLevel2 = true;
      existTagsFiltered1 = existTags;
    }
    if (!isSuppressibleLevel2) {
      const removeItems = [ get(thisNameLC) ];
      if (get(_setting).reduceNestedParent) removeItems.push(...get(trailLower));
      let tagsOnNextLevel = [];
      if ("tags" == viewType()) tagsOnNextLevel = uniqueCaseIntensive(existTags.map(e => {
        const idx = e.indexOf("/");
        if (idx < 1) return e;
        let piece = e.substring(0, idx + 1), idx2 = idx;
        for (;removeItems.some(e2 => e2.startsWith(piece.toLowerCase())); ) {
          idx2 = e.indexOf("/", idx2 + 1);
          if (-1 === idx2) {
            piece = e;
            break;
          }
          piece = e.substring(0, idx2 + 1);
        }
        return piece;
      })); else tagsOnNextLevel = unique(existTags);
      const trailShortest = removeIntermediatePath(trail());
      existTagsFiltered1 = tagsOnNextLevel.filter(tag2 => trailShortest.every(trail2 => trimTrailingSlash(tag2.toLowerCase()) !== trimTrailingSlash(trail2.toLowerCase())));
    }
    if (get(isMixedDedicatedTag) || get(isInDedicatedTag)) existTagsFiltered1 = existTagsFiltered1.map(e => e.replace(get(escapedPreviousTrail), get(previousTrail)));
    if (get(isMixedDedicatedTag) || get(isInDedicatedTag)) existTagsFiltered1 = existTagsFiltered1.map(e => e.replace(get(escapedPreviousTrail), get(previousTrail)));
    const existTagsFiltered1LC = existTagsFiltered1.map(e => e.toLowerCase());
    return {
      filteredTags: uniqueCaseIntensive(existTagsFiltered1.map(e => existTagsFiltered1LC.contains(e.toLowerCase() + "/") ? e + "/" : e)),
      isSuppressibleLevel: isSuppressibleLevel2
    };
  }), filteredTags = user_derived(() => get($$d).filteredTags), isSuppressibleLevel = user_derived(() => get($$d).isSuppressibleLevel), $$d_1 = user_derived(() => {
    let tags2 = [];
    const leftOverItemsSrc2 = [];
    if (!get(_items)) return {
      tags: tags2,
      leftOverItemsSrc: leftOverItemsSrc2
    };
    if (!($$props.isMainTree && (!get(expandLimit) || get(expandLimit) && depth() < get(expandLimit)))) return {
      tags: tags2,
      leftOverItemsSrc: leftOverItemsSrc2
    };
    if ("links" == viewType()) {
      const ret = get(tagsOfLinkedItems);
      return {
        tags: ret.tags,
        leftOverItemsSrc: ret.leftOverItems
      };
    }
    if (get(previousTrail).endsWith("/")) {
      const existTagsFiltered4 = [];
      for (const tag2 of get(filteredTags)) if (!get(filteredTags).map(e => e.toLowerCase()).contains((get(previousTrail) + tag2).toLowerCase())) existTagsFiltered4.push(tag2);
      tags2 = uniqueCaseIntensive(removeIntermediatePath(existTagsFiltered4));
    } else tags2 = uniqueCaseIntensive(removeIntermediatePath(get(filteredTags)));
    return {
      tags: tags2,
      leftOverItemsSrc: leftOverItemsSrc2
    };
  }), tags = user_derived(() => get($$d_1).tags), leftOverItemsSrc = user_derived(() => get($$d_1).leftOverItemsSrc), linkedItems = user_derived(() => {
    const ret = new Map;
    if ("tags" == viewType()) return ret;
    for (const tag2 of get(displayTagCandidates)) if ("_unlinked" == tag2) ret.set(tag2, get(_items).filter(e => e.links.contains(tag2))); else {
      const wItems = get(_items).filter(e => e.path == tag2);
      ret.set(tag2, wItems);
    }
    return ret;
  }), tagsOfLinkedItems = user_derived(() => {
    let leftOverItems2 = [], tags2 = [];
    if ("tags" == viewType()) return {
      tags: tags2,
      leftOverItems: leftOverItems2
    };
    if ("_unlinked" == thisName()) leftOverItems2 = get(_items); else get(displayTagCandidates).forEach(tag2 => {
      if ("_unlinked" == tag2) {
        tags2.push(tag2);
        return;
      }
      const x = getViewItemFromPath(tag2);
      if (null == x) return false;
      const existLinks = x.links.filter(e => !trail().contains(e) && e != thisName()), nextDepth = !get(expandLimit) || get(expandLimit) && depth() + 1 < get(expandLimit);
      if (existLinks.length >= 2 && nextDepth) tags2.push(tag2); else leftOverItems2.push(x);
    });
    return {
      tags: tags2,
      leftOverItems: leftOverItems2
    };
  }), leftOverItemsUnsorted = user_derived(() => {
    if (get(_setting).useMultiPaneList && $$props.isMainTree) return [];
    if ($$props.isRoot && $$props.isMainTree && !get(isSuppressibleLevel)) if (get(_setting).expandUntaggedToRoot) return get(_items).filter(e => e.tags.contains("_untagged") || e.tags.contains("_unlinked")); else return [];
    if ($$props.isRoot && !$$props.isMainTree) return get(_items);
    if ("tags" == viewType()) if ("NONE" == get(_setting).hideItems) return get(_items); else if ("DEDICATED_INTERMIDIATES" == get(_setting).hideItems && get(isInDedicatedTag) || "ALL_EXCEPT_BOTTOM" == get(_setting).hideItems) return get(_items).filter(e => !get(children).map(e2 => e2[V2FI_IDX_CHILDREN]).flat().find(ee => e.path == ee.path)); else return get(_items); else return get(leftOverItemsSrc);
  }), leftOverItems = user_derived(() => get(_setting).sortExactFirst ? performSortExactFirst(get(_items), get(children), get(leftOverItemsUnsorted)) : get(leftOverItemsUnsorted));
  let isActive = user_derived(() => get(_items) && get(_items).some(e => e.path == get(_currentActiveFilePath)) || "links" == viewType() && (thisName() == get(_currentActiveFilePath) || get(tags).contains(get(_currentActiveFilePath)) || get(leftOverItems).some(e => e.path == get(_currentActiveFilePath))));
  const tagsDisp = user_derived(() => get(isSuppressibleLevel) && get(isInDedicatedTag) ? [ [ ...tagNameDisp(), ...get(suppressLevels).flatMap(e => e.split("/").map(e2 => renderSpecialTag(e2))) ] ] : get(isSuppressibleLevel) ? [ tagNameDisp(), ...get(suppressLevels).map(e => e.split("/").map(e2 => renderSpecialTag(e2))) ] : [ tagNameDisp() ]), classKey = user_derived(() => "links" == viewType() ? " tf-link" : " tf-tag"), tagsDispHtml = user_derived(() => get(isFolderVisible) ? get(tagsDisp).map(e => `<span class="tagfolder-tag tag-tag${get(classKey)}">${e.map(ee => `<span class="tf-tag-each">${escapeStringToHTML(ee)}</span>`).join("")}</span>`).join("") : ""), itemCount = user_derived(() => "tags" == viewType() ? null !== (_c2 = null === get(_items) || void 0 === get(_items) ? void 0 : get(_items).length) && void 0 !== _c2 ? _c2 : 0 : get(tags).length + get(leftOverItems).length), leftOverItemsDisp = user_derived(() => splitArrayToBatch(get(leftOverItems))), childrenDisp = user_derived(() => splitArrayToBatch(get(children))), draggable = user_derived(() => !get(_setting).disableDragging), app = user_derived(() => store_get(pluginInstance, "$pluginInstance", $$stores).app), dm = user_derived(() => null === get(app) || void 0 === get(app) ? void 0 : get(app).dragManager);
  user_effect(() => {
    const key2 = get(trailKey) + ($$props.isRoot ? "-r" : "-x") + viewContextID, sortFunc = selectCompareMethodTags(get(_setting), "links" == viewType() ? {} : get(_tagInfo));
    (function updateX(param) {
      if (!isSameAny(param, _lastParam)) {
        _lastParam = {
          ...param
        };
        if (param.isFolderVisible || $$props.isRoot) scheduleOnceIfDuplicated("update-children-" + param.key, async () => {
          set(isUpdating, true);
          const ret = await collectTreeChildren(param);
          set(children, ret.children, true);
          set(suppressLevels, ret.suppressLevels, true);
          set(isUpdating, false);
        });
      }
    })({
      key: key2,
      expandLimit: get(expandLimit),
      depth: depth(),
      tags: get(tags),
      trailLower: get(trailLower),
      _setting: get(_setting),
      isMainTree: $$props.isMainTree,
      isSuppressibleLevel: get(isSuppressibleLevel),
      viewType: viewType(),
      previousTrail: get(previousTrail),
      _tagInfo: get(_tagInfo),
      _items: get(_items),
      linkedItems: get(linkedItems),
      isRoot: $$props.isRoot,
      isFolderVisible: get(isFolderVisible),
      sortFunc
    });
  });
  var div = root4();
  div.__click = toggleFolder;
  div.__contextmenu = evt => {
    evt.stopPropagation();
    if (shouldResponsibleFor(evt)) $$props.showMenu(evt, [ ...trail(), ...get(suppressLevels) ], "tags" == viewType() ? tagName() : get(filename), get(_items));
  };
  var node = child(div), consequent_1 = $$anchor2 => {
    var fragment = comment(), node_1 = first_child(fragment), consequent = $$anchor3 => {
      var div_1 = root_22(), div_2 = child(div_1), text2 = child(div_2, true);
      reset(div_2);
      reset(div_1);
      template_effect(() => set_text(text2, headerTitle()));
      append($$anchor3, div_1);
    };
    if_block(node_1, $$render => {
      if ($$props.isRoot) $$render(consequent);
    });
    append($$anchor2, fragment);
  }, alternate_2 = $$anchor2 => {
    {
      let $0 = user_derived(() => `tree-item-self${!$$props.isRoot ? " is-clickable mod-collapsible" : ""} nav-folder-title tag-folder-title${get(isActive) ? " is-active" : ""}`);
      OnDemandRender($$anchor2, {
        get cssClass() {
          return get($0);
        },
        get isVisible() {
          return get(isFolderVisible);
        },
        set isVisible($$value) {
          set(isFolderVisible, $$value, true);
        },
        children: ($$anchor3, $$slotProps) => {
          var fragment_2 = root_4(), div_3 = first_child(fragment_2);
          let classes;
          div_3.__click = toggleFolder;
          var node_2 = child(div_3), consequent_2 = $$anchor4 => {
            var fragment_3 = comment();
            html(first_child(fragment_3), folderIcon);
            append($$anchor4, fragment_3);
          }, alternate = $$anchor4 => {
            append($$anchor4, root_6());
          };
          if_block(node_2, $$render => {
            if (get(isFolderVisible)) $$render(consequent_2); else $$render(alternate, false);
          });
          reset(div_3);
          var div_4 = sibling(div_3, 2);
          div_4.__click = handleOpenItem;
          var node_4 = child(div_4), consequent_3 = $$anchor4 => {
            var div_5 = root_7();
            html(child(div_5), () => get(tagsDispHtml));
            reset(div_5);
            template_effect(() => set_attribute2(div_5, "draggable", get(draggable)));
            event("dragstart", div_5, dragStartName);
            append($$anchor4, div_5);
          }, alternate_1 = $$anchor4 => {
            append($$anchor4, root_8());
          };
          if_block(node_4, $$render => {
            if (get(isFolderVisible)) $$render(consequent_3); else $$render(alternate_1, false);
          });
          var div_7 = sibling(node_4, 2);
          div_7.__click = e => function handleOpenScroll(e, trails, filePaths) {
            if ("tags" == viewType()) $$props.openScrollView(void 0, "", joinPartialPath(removeIntermediatePath(trails)).join(", "), filePaths); else if ("links" == viewType()) $$props.openScrollView(void 0, "", `Linked to ${get(filename)}`, filePaths);
            e.preventDefault();
          }(e, trail(), get(_items).map(e2 => e2.path));
          var span = child(div_7), text_1 = child(span, true);
          reset(span);
          reset(div_7);
          reset(div_4);
          template_effect(() => {
            classes = set_class(div_3, 1, "tree-item-icon collapse-icon nav-folder-collapse-indicator", null, classes, {
              "is-collapsed": get(collapsed)
            });
            set_attribute2(span, "draggable", get(draggable));
            set_text(text_1, get(itemCount));
          });
          event("dragstart", span, dragStartFiles);
          append($$anchor3, fragment_2);
        },
        $$slots: {
          default: true
        }
      });
    }
  };
  if_block(node, $$render => {
    if ($$props.isRoot || !$$props.isMainTree) $$render(consequent_1); else $$render(alternate_2, false);
  });
  var node_6 = sibling(node, 2), consequent_5 = $$anchor2 => {
    var fragment_9 = comment();
    const treeContent = ($$anchor3, childrenDisp2 = noop, leftOverItemsDisp2 = noop) => {
      var fragment_4 = root_10(), node_7 = first_child(fragment_4);
      each(node_7, 17, childrenDisp2, index, ($$anchor4, items2, $$index_1, $$array) => {
        var fragment_5 = comment();
        each(first_child(fragment_5), 17, () => get(items2), index, ($$anchor5, $$item, $$index, $$array_1) => {
          var $$array_2 = user_derived(() => to_array(get($$item), 4));
          let f = () => get($$array_2)[0];
          {
            let $0 = user_derived(() => [ ...trail(), ...get(suppressLevels), f() ]), $1 = user_derived(() => get(isInDedicatedTag) ? depth() : depth() + 1);
            V2TreeFolderComponent_1($$anchor5, {
              get viewType() {
                return viewType();
              },
              get items() {
                return get($$array_2)[3];
              },
              get thisName() {
                return f();
              },
              get trail() {
                return get($0);
              },
              get folderIcon() {
                return folderIcon();
              },
              get openFile() {
                return $$props.openFile;
              },
              isRoot: false,
              get showMenu() {
                return $$props.showMenu;
              },
              get isMainTree() {
                return $$props.isMainTree;
              },
              get openScrollView() {
                return $$props.openScrollView;
              },
              get hoverPreview() {
                return $$props.hoverPreview;
              },
              get tagName() {
                return get($$array_2)[1];
              },
              get tagNameDisp() {
                return get($$array_2)[2];
              },
              get depth() {
                return get($1);
              }
            });
          }
        });
        append($$anchor4, fragment_5);
      });
      each(sibling(node_7, 2), 17, leftOverItemsDisp2, index, ($$anchor4, items2, $$index_3, $$array_3) => {
        var fragment_7 = comment();
        each(first_child(fragment_7), 17, () => get(items2), index, ($$anchor5, item) => {
          {
            let $0 = user_derived(() => $$props.isRoot ? [ ...trail() ] : [ ...trail(), ...get(suppressLevels) ]);
            V2TreeItemComponent($$anchor5, {
              get item() {
                return get(item);
              },
              get openFile() {
                return $$props.openFile;
              },
              get trail() {
                return get($0);
              },
              get showMenu() {
                return $$props.showMenu;
              },
              get hoverPreview() {
                return $$props.hoverPreview;
              }
            });
          }
        });
        append($$anchor4, fragment_7);
      });
      append($$anchor3, fragment_4);
    };
    var node_11 = first_child(fragment_9), consequent_4 = $$anchor3 => {
      var div_8 = root_15(), node_12 = child(div_8);
      treeContent(node_12, () => get(childrenDisp), () => get(leftOverItemsDisp));
      reset(div_8);
      append($$anchor3, div_8);
    }, alternate_3 = $$anchor3 => {
      treeContent($$anchor3, () => get(childrenDisp), () => get(leftOverItemsDisp));
    };
    if_block(node_11, $$render => {
      if (!$$props.isRoot) $$render(consequent_4); else $$render(alternate_3, false);
    });
    append($$anchor2, fragment_9);
  };
  if_block(node_6, $$render => {
    if (!get(collapsed)) $$render(consequent_5);
  });
  reset(div);
  template_effect(() => set_class(div, 1, `tree-item nav-folder${get(collapsed) ? " is-collapsed" : ""}${$$props.isRoot ? " mod-root" : ""}${get(isUpdating) ? " updating" : ""}`));
  append($$anchor, div);
  pop();
  $$cleanup();
}

delegate([ "click", "contextmenu" ]);

var import_obsidian3 = require("obsidian"), root_13 = from_html('<div class="clickable-icon nav-action-button" aria-label="Change sort order"><!></div>  <div class="clickable-icon nav-action-button" aria-label="Expand limit"><!></div>  <div aria-label="Search"><!></div>', 1), root_23 = from_html('<div class="clickable-icon nav-action-button" aria-label="Switch List/Tree"><!></div>'), root_3 = from_html('<div aria-label="Toggle Incoming"><!></div>  <div aria-label="Toggle Outgoing"><!></div>  <div aria-label="Toggle Incoming&amp;Outgoing"><!></div>  <div aria-label="Toggle Hide indirect notes"><!></div>', 1), root_42 = from_html('<div class="clickable-icon nav-action-button" aria-label="Collapse all"><!></div>'), root_5 = from_html('<div class="search-row"><div class="search-input-container global-search-input-container"><input type="search" spellcheck="false" placeholder="Type to start search..."/>  <div class="search-input-clear-button" aria-label="Clear search"></div></div></div>'), root5 = from_html('<div hidden=""></div> <div class="nav-header"><div class="nav-buttons-container tagfolder-buttons-container"><div class="clickable-icon nav-action-button" aria-label="New note"><!></div> <!> <!> <!> <!></div></div> <!> <div class="nav-files-container node-insert-event svelte-10n2ssk"><!></div>', 1), $$css3 = {
  hash: "svelte-10n2ssk",
  code: ".nav-files-container.svelte-10n2ssk {height:100%;}"
};

function TagFolderViewComponent($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css3);
  const $searchString = () => store_get(searchString, "$searchString", $$stores), [$$stores, $$cleanup] = setup_stores();
  let vaultName = prop($$props, "vaultName", 3, ""), title = prop($$props, "title", 15, ""), tags = prop($$props, "tags", 31, () => proxy([])), viewType = prop($$props, "viewType", 3, "tags");
  const isMainTree = user_derived(() => 0 == tags().length);
  user_effect(() => {
    if ($$props.stateStore) {
      let unsubscribe = $$props.stateStore.subscribe(state2 => {
        tags(state2.tags);
        title(state2.title);
      });
      return () => {
        unsubscribe();
      };
    }
  });
  let updatedFiles = state(proxy([]));
  appliedFiles.subscribe(async filenames => {
    set(updatedFiles, null != filenames ? filenames : [], true);
  });
  const viewItemsSrc = user_derived(() => {
    if ("tags" == viewType()) return store_get(allViewItems, "$allViewItems", $$stores); else return store_get(allViewItemsByLink, "$allViewItemsByLink", $$stores);
  });
  let _setting = state(proxy(store_get(tagFolderSetting, "$tagFolderSetting", $$stores))), outgoingEnabled = state(false), incomingEnabled = state(false), bothEnabled = state(false), onlyFDREnabled = state(false);
  tagFolderSetting.subscribe(setting => {
    var _a3, _b3, _c2, _d, _e, _f;
    set(_setting, setting, true);
    const incoming = null !== (_c2 = null === (_b3 = null === (_a3 = get(_setting).linkConfig) || void 0 === _a3 ? void 0 : _a3.incoming) || void 0 === _b3 ? void 0 : _b3.enabled) && void 0 !== _c2 ? _c2 : false, outgoing = null !== (_f = null === (_e = null === (_d = get(_setting).linkConfig) || void 0 === _d ? void 0 : _d.outgoing) || void 0 === _e ? void 0 : _e.enabled) && void 0 !== _f ? _f : false;
    if (!incoming && !outgoing) {
      let newSet = {
        ...get(_setting)
      };
      newSet.linkConfig.incoming.enabled = true;
      newSet.linkConfig.outgoing.enabled = true;
      if ($$props.saveSettings) $$props.saveSettings(newSet);
      set(bothEnabled, true);
    } else {
      set(outgoingEnabled, !incoming && outgoing, true);
      set(incomingEnabled, incoming && !outgoing, true);
      set(bothEnabled, incoming && outgoing, true);
    }
    set(onlyFDREnabled, get(_setting).linkShowOnlyFDR, true);
  });
  let showSearch = state(false);
  function toggleSearch() {
    set(showSearch, !get(showSearch));
    if (!get(showSearch)) store_set(searchString, "");
  }
  function clearSearch() {
    store_set(searchString, "");
  }
  function doSwitch() {
    if ($$props.switchView) $$props.switchView();
  }
  let observer, iconDivEl = state(void 0), newNoteIcon = state(""), folderIcon = state(""), upAndDownArrowsIcon = state(""), stackedLevels = state(""), searchIcon = state(""), switchIcon = state(""), outgoingIcon = state(""), incomingIcon = state(""), bothIcon = state(""), linkIcon = state(""), closeAllIcon = state("");
  async function switchIncoming() {
    let newSet = {
      ...get(_setting)
    };
    newSet.linkConfig.incoming.enabled = true;
    newSet.linkConfig.outgoing.enabled = false;
    if ($$props.saveSettings) await $$props.saveSettings(newSet);
  }
  async function switchOutgoing() {
    let newSet = {
      ...get(_setting)
    };
    newSet.linkConfig.incoming.enabled = false;
    newSet.linkConfig.outgoing.enabled = true;
    if ($$props.saveSettings) await $$props.saveSettings(newSet);
  }
  async function switchBoth() {
    let newSet = {
      ...get(_setting)
    };
    newSet.linkConfig.incoming.enabled = true;
    newSet.linkConfig.outgoing.enabled = true;
    if ($$props.saveSettings) await $$props.saveSettings(newSet);
  }
  async function switchOnlyFDR() {
    let newSet = {
      ...get(_setting)
    };
    newSet.linkShowOnlyFDR = !get(_setting).linkShowOnlyFDR;
    if ($$props.saveSettings) await $$props.saveSettings(newSet);
  }
  let scrollParent, observingElements = new Map, observingElQueue = [];
  function unobserve(el) {
    null == observer || observer.unobserve(el);
  }
  function observeAllQueued() {
    observingElQueue.forEach(el => {
      null == observer || observer.observe(el);
    });
    observingElQueue = [];
  }
  setContext("observer", {
    observe: function observe(el, callback) {
      if (!observer) observingElQueue.push(el); else if (observingElQueue.length > 0) observeAllQueued();
      if (observingElements.has(el)) {
        unobserve(el);
        observingElements.delete(el);
      }
      observingElements.set(el, {
        callback,
        lastState: void 0
      });
      null == observer || observer.observe(el);
    },
    unobserve
  });
  onMount(() => {
    observer = new IntersectionObserver(ex => {
      for (const v of ex) if (observingElements.has(v.target)) {
        const tg = observingElements.get(v.target);
        if (tg && tg.lastState !== v.isIntersecting) {
          tg.lastState = v.isIntersecting;
          setTimeout(() => tg.callback(v.isIntersecting), 10);
        }
      }
    }, {
      root: scrollParent,
      rootMargin: "40px 0px",
      threshold: 0
    });
    observeAllQueued();
    if (get(iconDivEl)) {
      (0, import_obsidian3.setIcon)(get(iconDivEl), "right-triangle");
      set(folderIcon, `${get(iconDivEl).innerHTML}`);
      (0, import_obsidian3.setIcon)(get(iconDivEl), "lucide-edit");
      set(newNoteIcon, `${get(iconDivEl).innerHTML}`);
      if (get(isMainTree)) {
        (0, import_obsidian3.setIcon)(get(iconDivEl), "lucide-sort-asc");
        set(upAndDownArrowsIcon, get(iconDivEl).innerHTML, true);
        (0, import_obsidian3.setIcon)(get(iconDivEl), "stacked-levels");
        set(stackedLevels, get(iconDivEl).innerHTML, true);
        (0, import_obsidian3.setIcon)(get(iconDivEl), "search");
        set(searchIcon, get(iconDivEl).innerHTML, true);
      }
      if ("links" == viewType()) {
        (0, import_obsidian3.setIcon)(get(iconDivEl), "links-coming-in");
        set(incomingIcon, get(iconDivEl).innerHTML, true);
        (0, import_obsidian3.setIcon)(get(iconDivEl), "links-going-out");
        set(outgoingIcon, get(iconDivEl).innerHTML, true);
        (0, import_obsidian3.setIcon)(get(iconDivEl), "link");
        set(linkIcon, get(iconDivEl).innerHTML, true);
        (0, import_obsidian3.setIcon)(get(iconDivEl), "lucide-link-2");
        set(bothIcon, get(iconDivEl).innerHTML, true);
      }
      (0, import_obsidian3.setIcon)(get(iconDivEl), "lucide-arrow-left-right");
      set(switchIcon, get(iconDivEl).innerHTML, true);
      (0, import_obsidian3.setIcon)(get(iconDivEl), "lucide-chevrons-down-up");
      set(closeAllIcon, get(iconDivEl).innerHTML, true);
    }
    const int = setInterval(() => {
      performHide.set(Date.now());
    }, 5e3);
    return () => {
      clearInterval(int);
    };
  });
  onDestroy(() => {
    null == observer || observer.disconnect();
  });
  let headerTitle = user_derived(() => "" == title() ? `${"tags" == viewType() ? "Tags" : "Links"}: ${vaultName()}` : `Items: ${title()}`);
  const viewItems = user_derived(() => {
    var _a3;
    if (!get(viewItemsSrc)) return [];
    if (get(isMainTree)) return get(viewItemsSrc);
    let items = get(viewItemsSrc);
    const lowerTags = tags().map(e => e.toLowerCase());
    for (const tag2 of lowerTags) items = items.filter(e => e.tags.some(e2 => (e2.toLowerCase() + "/").startsWith(tag2)));
    const firstLevel = trimTrailingSlash(null !== (_a3 = tags().first()) && void 0 !== _a3 ? _a3 : "").toLowerCase(), archiveTags = get(_setting).archiveTags.toLowerCase().replace(/[\n ]/g, "").split(",");
    if (!archiveTags.contains(firstLevel)) items = items.filter(item => !item.tags.some(e => archiveTags.contains(e.toLowerCase())));
    return items;
  });
  setContext("viewID", `${Math.random()}`);
  function closeAllOpenedFolders() {
    v2expandedTags.update(prev => {
      prev.clear();
      return prev;
    });
  }
  var fragment = root5(), div = first_child(fragment);
  bind_this(div, $$value => set(iconDivEl, $$value), () => get(iconDivEl));
  var div_1 = sibling(div, 2), div_2 = child(div_1), div_3 = child(div_2);
  div_3.__click = function(...$$args) {
    var _a3;
    null == (_a3 = $$props.newNote) || _a3.apply(this, $$args);
  };
  html(child(div_3), () => get(newNoteIcon));
  reset(div_3);
  var node_1 = sibling(div_3, 2), consequent = $$anchor2 => {
    var fragment_1 = root_13(), div_4 = first_child(fragment_1);
    div_4.__click = function(...$$args) {
      var _a3;
      null == (_a3 = $$props.showOrder) || _a3.apply(this, $$args);
    };
    html(child(div_4), () => get(upAndDownArrowsIcon));
    reset(div_4);
    var div_5 = sibling(div_4, 2);
    div_5.__click = function(...$$args) {
      var _a3;
      null == (_a3 = $$props.showLevelSelect) || _a3.apply(this, $$args);
    };
    html(child(div_5), () => get(stackedLevels));
    reset(div_5);
    var div_6 = sibling(div_5, 2);
    div_6.__click = toggleSearch;
    html(child(div_6), () => get(searchIcon));
    reset(div_6);
    template_effect(() => set_class(div_6, 1, "clickable-icon nav-action-button " + (get(showSearch) ? " is-active" : ""), "svelte-10n2ssk"));
    append($$anchor2, fragment_1);
  };
  if_block(node_1, $$render => {
    if (get(isMainTree)) $$render(consequent);
  });
  var node_5 = sibling(node_1, 2), consequent_1 = $$anchor2 => {
    var div_7 = root_23();
    div_7.__click = doSwitch;
    html(child(div_7), () => get(switchIcon));
    reset(div_7);
    append($$anchor2, div_7);
  };
  if_block(node_5, $$render => {
    if ($$props.isViewSwitchable) $$render(consequent_1);
  });
  var node_7 = sibling(node_5, 2), consequent_2 = $$anchor2 => {
    var fragment_2 = root_3(), div_8 = first_child(fragment_2);
    let classes;
    div_8.__click = switchIncoming;
    html(child(div_8), () => get(incomingIcon));
    reset(div_8);
    var div_9 = sibling(div_8, 2);
    let classes_1;
    div_9.__click = switchOutgoing;
    html(child(div_9), () => get(outgoingIcon));
    reset(div_9);
    var div_10 = sibling(div_9, 2);
    let classes_2;
    div_10.__click = switchBoth;
    html(child(div_10), () => get(bothIcon));
    reset(div_10);
    var div_11 = sibling(div_10, 2);
    let classes_3;
    div_11.__click = switchOnlyFDR;
    html(child(div_11), () => get(linkIcon));
    reset(div_11);
    template_effect(() => {
      classes = set_class(div_8, 1, "clickable-icon nav-action-button", null, classes, {
        "is-active": get(incomingEnabled)
      });
      classes_1 = set_class(div_9, 1, "clickable-icon nav-action-button", null, classes_1, {
        "is-active": get(outgoingEnabled)
      });
      classes_2 = set_class(div_10, 1, "clickable-icon nav-action-button", null, classes_2, {
        "is-active": get(bothEnabled)
      });
      classes_3 = set_class(div_11, 1, "clickable-icon nav-action-button", null, classes_3, {
        "is-active": get(onlyFDREnabled)
      });
    });
    append($$anchor2, fragment_2);
  };
  if_block(node_7, $$render => {
    if ("links" == viewType()) $$render(consequent_2);
  });
  var node_12 = sibling(node_7, 2), consequent_3 = $$anchor2 => {
    var div_12 = root_42();
    div_12.__click = closeAllOpenedFolders;
    html(child(div_12), () => get(closeAllIcon));
    reset(div_12);
    append($$anchor2, div_12);
  };
  if_block(node_12, $$render => {
    if (get(isMainTree)) $$render(consequent_3);
  });
  reset(div_2);
  reset(div_1);
  var node_14 = sibling(div_1, 2), consequent_4 = $$anchor2 => {
    var div_13 = root_5(), div_14 = child(div_13), input = child(div_14);
    remove_input_defaults(input);
    var div_15 = sibling(input, 2);
    div_15.__click = clearSearch;
    reset(div_14);
    reset(div_13);
    template_effect($0 => set_style(div_15, `display:${null != $0 ? $0 : ""};`), [ () => "" == $searchString().trim() ? "none" : "" ]);
    bind_value(input, $searchString, $$value => store_set(searchString, $$value));
    append($$anchor2, div_13);
  };
  if_block(node_14, $$render => {
    if (get(showSearch) && get(isMainTree)) $$render(consequent_4);
  });
  var div_16 = sibling(node_14, 2);
  V2TreeFolderComponent_1(child(div_16), {
    get viewType() {
      return viewType();
    },
    get items() {
      return get(viewItems);
    },
    get folderIcon() {
      return get(folderIcon);
    },
    thisName: "",
    isRoot: true,
    get showMenu() {
      return $$props.showMenu;
    },
    get openFile() {
      return $$props.openFile;
    },
    get isMainTree() {
      return get(isMainTree);
    },
    get hoverPreview() {
      return $$props.hoverPreview;
    },
    get openScrollView() {
      return $$props.openScrollView;
    },
    depth: 1,
    get headerTitle() {
      return get(headerTitle);
    }
  });
  reset(div_16);
  bind_this(div_16, $$value => scrollParent = $$value, () => scrollParent);
  append($$anchor, fragment);
  pop();
  $$cleanup();
}

delegate([ "click" ]);

var import_obsidian5 = require("obsidian"), import_obsidian4 = require("obsidian"), askString = (app, title, placeholder, initialText) => new Promise(res => {
  new PopoverSelectString(app, title, placeholder, initialText, result => res(result)).open();
}), PopoverSelectString = class extends import_obsidian4.SuggestModal {
  constructor(app, title, placeholder, initialText, callback) {
    super(app);
    this.callback = () => {};
    this.title = "";
    this.app = app;
    this.title = title;
    this.setPlaceholder(null != placeholder ? placeholder : ">");
    this.callback = callback;
    setTimeout(() => {
      this.inputEl.value = initialText;
    });
    const parent = this.containerEl.querySelector(".prompt");
    if (parent) parent.addClass("override-input");
  }
  getSuggestions(query) {
    return [ query ];
  }
  renderSuggestion(value, el) {
    el.createDiv({
      text: `${this.title}${value}`
    });
  }
  onChooseSuggestion(item, evt) {
    var _a3;
    null == (_a3 = this.callback) || _a3.call(this, item);
    this.callback = void 0;
  }
  onClose() {
    setTimeout(() => {
      if (this.callback) this.callback(false);
    }, 100);
  }
};

function toggleObjectProp(obj, propName, value) {
  if (false === value) {
    const newTagInfoEntries = Object.entries(obj || {}).filter(([key2]) => key2 != propName);
    if (0 == newTagInfoEntries.length) return {}; else return Object.fromEntries(newTagInfoEntries);
  } else return {
    ...null != obj ? obj : {},
    [propName]: value
  };
}

var TagFolderViewBase = class extends import_obsidian5.ItemView {
  constructor() {
    super(...arguments);
    this.navigation = false;
  }
  async saveSettings(settings) {
    this.plugin.settings = {
      ...this.plugin.settings,
      ...settings
    };
    await this.plugin.saveSettings();
    this.plugin.updateFileCaches();
  }
  showOrder(evt) {
    const menu = new import_obsidian5.Menu;
    menu.addItem(item => {
      item.setTitle("Tags").setIcon("hashtag").onClick(evt2 => {
        const menu2 = new import_obsidian5.Menu;
        for (const key2 in OrderKeyTag) for (const direction in OrderDirection) menu2.addItem(item2 => {
          const newSetting = `${key2}_${direction}`;
          item2.setTitle(OrderKeyTag[key2] + " " + OrderDirection[direction]).onClick(async () => {
            this.plugin.settings.sortTypeTag = newSetting;
            await this.plugin.saveSettings();
          });
          if (newSetting == this.plugin.settings.sortTypeTag) item2.setIcon("checkmark");
          return item2;
        });
        menu2.showAtPosition({
          x: evt.x,
          y: evt.y
        });
      });
      return item;
    });
    menu.addItem(item => {
      item.setTitle("Items").setIcon("document").onClick(evt2 => {
        const menu2 = new import_obsidian5.Menu;
        for (const key2 in OrderKeyItem) for (const direction in OrderDirection) menu2.addItem(item2 => {
          const newSetting = `${key2}_${direction}`;
          item2.setTitle(OrderKeyItem[key2] + " " + OrderDirection[direction]).onClick(async () => {
            this.plugin.settings.sortType = newSetting;
            await this.plugin.saveSettings();
          });
          if (newSetting == this.plugin.settings.sortType) item2.setIcon("checkmark");
          return item2;
        });
        menu2.showAtPosition({
          x: evt.x,
          y: evt.y
        });
      });
      return item;
    });
    menu.showAtMouseEvent(evt);
  }
  showLevelSelect(evt) {
    const menu = new import_obsidian5.Menu, setLevel = async level => {
      this.plugin.settings.expandLimit = level;
      await this.plugin.saveSettings();
      maxDepth.set(level);
    };
    for (const level of [ 2, 3, 4, 5 ]) menu.addItem(item => {
      item.setTitle("Level " + (level - 1)).onClick(() => {
        setLevel(level);
      });
      if (this.plugin.settings.expandLimit == level) item.setIcon("checkmark");
      return item;
    });
    menu.addItem(item => {
      item.setTitle("No limit").onClick(() => {
        setLevel(0);
      });
      if (0 == this.plugin.settings.expandLimit) item.setIcon("checkmark");
      return item;
    });
    menu.showAtMouseEvent(evt);
  }
  showMenu(evt, trail, targetTag, targetItems) {
    const isTagTree = this.getViewType() == VIEW_TYPE_TAGFOLDER, menu = new import_obsidian5.Menu;
    if (isTagTree) {
      const expandedTagsAll = ancestorToLongestTag(ancestorToTags(joinPartialPath(removeIntermediatePath(trail)))).map(e => trimTrailingSlash(e)), expandedTags = expandedTagsAll.map(e => e.split("/").filter(ee => !isSpecialTag(ee)).join("/")).filter(e => "" != e).map(e => "#" + e).join(" ").trim(), displayExpandedTags = expandedTagsAll.map(e => e.split("/").filter(ee => renderSpecialTag(ee)).join("/")).filter(e => "" != e).map(e => "#" + e).join(" ").trim();
      if (navigator && navigator.clipboard) menu.addItem(item => item.setTitle(`Copy tags:${expandedTags}`).setIcon("hashtag").onClick(async () => {
        await navigator.clipboard.writeText(expandedTags);
        new import_obsidian5.Notice("Copied");
      }));
      menu.addItem(item => item.setTitle("New note " + (targetTag ? "in here" : "as like this")).setIcon("create-new").onClick(async () => {
        await this.plugin.createNewNote(trail);
      }));
      if (targetTag) if (this.plugin.settings.useTagInfo && null != this.plugin.tagInfo) {
        const tag2 = targetTag;
        if (tag2 in this.plugin.tagInfo && "key" in this.plugin.tagInfo[tag2]) menu.addItem(item => item.setTitle("Unpin").setIcon("pin").onClick(async () => {
          this.plugin.tagInfo[tag2] = toggleObjectProp(this.plugin.tagInfo[tag2], "key", false);
          this.plugin.applyTagInfo();
          await this.plugin.saveTagInfo();
        })); else menu.addItem(item => {
          item.setTitle("Pin").setIcon("pin").onClick(async () => {
            this.plugin.tagInfo[tag2] = toggleObjectProp(this.plugin.tagInfo[tag2], "key", "");
            this.plugin.applyTagInfo();
            await this.plugin.saveTagInfo();
          });
        });
        menu.addItem(item => {
          item.setTitle("Set an alternative label").setIcon("pencil").onClick(async () => {
            var _a3;
            const oldAlt = tag2 in this.plugin.tagInfo ? null != (_a3 = this.plugin.tagInfo[tag2].alt) ? _a3 : "" : "", label = await askString(this.app, "", "", oldAlt);
            if (false !== label) {
              this.plugin.tagInfo[tag2] = toggleObjectProp(this.plugin.tagInfo[tag2], "alt", "" == label ? false : label);
              this.plugin.applyTagInfo();
              await this.plugin.saveTagInfo();
            }
          });
        });
        menu.addItem(item => {
          item.setTitle("Change the mark").setIcon("pencil").onClick(async () => {
            var _a3;
            const oldMark = tag2 in this.plugin.tagInfo ? null != (_a3 = this.plugin.tagInfo[tag2].mark) ? _a3 : "" : "", mark = await askString(this.app, "", "", oldMark);
            if (false !== mark) {
              this.plugin.tagInfo[tag2] = toggleObjectProp(this.plugin.tagInfo[tag2], "mark", "" == mark ? false : mark);
              this.plugin.applyTagInfo();
              await this.plugin.saveTagInfo();
            }
          });
        });
        menu.addItem(item => {
          item.setTitle("Redirect this tag to ...").setIcon("pencil").onClick(async () => {
            var _a3;
            const oldRedirect = tag2 in this.plugin.tagInfo ? null != (_a3 = this.plugin.tagInfo[tag2].redirect) ? _a3 : "" : "", redirect = await askString(this.app, "", "", oldRedirect);
            if (false !== redirect) {
              this.plugin.tagInfo[tag2] = toggleObjectProp(this.plugin.tagInfo[tag2], "redirect", "" == redirect ? false : redirect);
              this.plugin.applyTagInfo();
              await this.plugin.saveTagInfo();
            }
          });
        });
        if (targetItems) {
          menu.addItem(item => {
            item.setTitle("Open scroll view").setIcon("sheets-in-box").onClick(async () => {
              const files = targetItems.map(e => e.path);
              await this.plugin.openScrollView(void 0, displayExpandedTags, expandedTagsAll.join(", "), files);
            });
          });
          menu.addItem(item => {
            item.setTitle("Open list").setIcon("sheets-in-box").onClick(() => {
              selectedTags.set(expandedTagsAll);
            });
          });
        }
      }
    }
    if (!targetTag && targetItems && 1 == targetItems.length) {
      const path = targetItems[0].path, file = this.app.vault.getAbstractFileByPath(path);
      this.app.workspace.trigger("file-menu", menu, file, "file-explorer");
      menu.addSeparator();
      menu.addItem(item => item.setTitle("Open in new tab").setSection("open").setIcon("lucide-file-plus").onClick(async () => {
        await this.app.workspace.openLinkText(path, path, "tab");
      }));
      menu.addItem(item => item.setTitle("Open to the right").setSection("open").setIcon("lucide-separator-vertical").onClick(async () => {
        await this.app.workspace.openLinkText(path, path, "split");
      }));
    } else if (!isTagTree && targetTag) {
      const path = targetTag, file = this.app.vault.getAbstractFileByPath(path);
      this.app.workspace.trigger("file-menu", menu, file, "file-explorer");
      menu.addSeparator();
      menu.addItem(item => item.setTitle("Open in new tab").setSection("open").setIcon("lucide-file-plus").onClick(async () => {
        await this.app.workspace.openLinkText(path, path, "tab");
      }));
      menu.addItem(item => item.setTitle("Open to the right").setSection("open").setIcon("lucide-separator-vertical").onClick(async () => {
        await this.app.workspace.openLinkText(path, path, "split");
      }));
    }
    if ("screenX" in evt) menu.showAtPosition({
      x: evt.pageX,
      y: evt.pageY
    }); else menu.showAtPosition({
      x: evt.nativeEvent.locationX,
      y: evt.nativeEvent.locationY
    });
    evt.preventDefault();
  }
  switchView() {
    let viewType = VIEW_TYPE_TAGFOLDER;
    const currentType = this.getViewType();
    if (currentType == VIEW_TYPE_TAGFOLDER) viewType = VIEW_TYPE_TAGFOLDER_LIST; else if (currentType == VIEW_TYPE_TAGFOLDER_LINK) return; else if (currentType == VIEW_TYPE_TAGFOLDER_LIST) viewType = VIEW_TYPE_TAGFOLDER;
    const leaves = this.app.workspace.getLeavesOfType(viewType).filter(e => !e.getViewState().pinned && e != this.leaf);
    if (leaves.length) this.app.workspace.revealLeaf(leaves[0]);
  }
}, TagFolderView = class extends TagFolderViewBase {
  constructor(leaf, plugin, viewType) {
    super(leaf);
    this.icon = "stacked-levels";
    this.plugin = plugin;
    this.showMenu = this.showMenu.bind(this);
    this.showOrder = this.showOrder.bind(this);
    this.newNote = this.newNote.bind(this);
    this.showLevelSelect = this.showLevelSelect.bind(this);
    this.switchView = this.switchView.bind(this);
    this.treeViewType = viewType;
  }
  getIcon() {
    return "stacked-levels";
  }
  newNote(evt) {
    this.app.commands.executeCommandById("file-explorer:new-file");
  }
  getViewType() {
    return "tags" == this.treeViewType ? VIEW_TYPE_TAGFOLDER : VIEW_TYPE_TAGFOLDER_LINK;
  }
  getDisplayText() {
    return "tags" == this.treeViewType ? "Tag Folder" : "Link Folder";
  }
  async onOpen() {
    this.containerEl.empty();
    const app = mount(TagFolderViewComponent, {
      target: this.containerEl,
      props: {
        openFile: this.plugin.focusFile,
        hoverPreview: (a, b) => this.plugin.hoverPreview(a, b),
        vaultName: this.app.vault.getName(),
        showMenu: this.showMenu,
        showLevelSelect: this.showLevelSelect,
        showOrder: this.showOrder,
        newNote: this.newNote,
        openScrollView: this.plugin.openScrollView,
        isViewSwitchable: this.plugin.settings.useMultiPaneList,
        switchView: this.switchView,
        viewType: this.treeViewType,
        saveSettings: this.saveSettings.bind(this)
      }
    });
    this.component = app;
    return await Promise.resolve();
  }
  async onClose() {
    await unmount(this.component);
    this.component = void 0;
    return await Promise.resolve();
  }
}, import_obsidian7 = require("obsidian"), TagFolderList = class extends TagFolderViewBase {
  constructor(leaf, plugin) {
    super(leaf);
    this.icon = "stacked-levels";
    this.title = "";
    this.state = {
      tags: [],
      title: ""
    };
    this.stateStore = writable(this.state);
    this.plugin = plugin;
    this.showMenu = this.showMenu.bind(this);
    this.showOrder = this.showOrder.bind(this);
    this.newNote = this.newNote.bind(this);
    this.showLevelSelect = this.showLevelSelect.bind(this);
    this.switchView = this.switchView.bind(this);
  }
  onPaneMenu(menu, source2) {
    super.onPaneMenu(menu, source2);
    menu.addItem(item => {
      item.setIcon("pin").setTitle("Pin").onClick(() => {
        this.leaf.togglePinned();
      });
    });
  }
  getIcon() {
    return "stacked-levels";
  }
  async setState(state2, result) {
    this.state = {
      ...this.state,
      ...state2
    };
    this.title = state2.tags.join(",");
    this.stateStore.set(this.state);
    return await Promise.resolve();
  }
  getState() {
    return this.state;
  }
  async newNote(evt) {
    await this.plugin.createNewNote(this.state.tags);
  }
  getViewType() {
    return VIEW_TYPE_TAGFOLDER_LIST;
  }
  getDisplayText() {
    return `Files with ${this.state.title}`;
  }
  async onOpen() {
    this.containerEl.empty();
    this.component = mount(TagFolderViewComponent, {
      target: this.containerEl,
      props: {
        openFile: this.plugin.focusFile,
        hoverPreview: this.plugin.hoverPreview,
        title: "",
        showMenu: this.showMenu,
        showLevelSelect: this.showLevelSelect,
        showOrder: this.showOrder,
        newNote: this.newNote,
        openScrollView: this.plugin.openScrollView,
        isViewSwitchable: this.plugin.settings.useMultiPaneList,
        switchView: this.switchView,
        saveSettings: this.saveSettings.bind(this),
        stateStore: this.stateStore
      }
    });
    return await Promise.resolve();
  }
  async onClose() {
    if (this.component) {
      await unmount(this.component);
      this.component = void 0;
    }
    return await Promise.resolve();
  }
}, HideItemsType = {
  NONE: "Hide nothing",
  DEDICATED_INTERMIDIATES: "Only intermediates of nested tags",
  ALL_EXCEPT_BOTTOM: "All intermediates"
};

function dotted(object, notation) {
  return notation.split(".").reduce((a, b) => a && b in a ? a[b] : null, object);
}

function getCompareMethodItems(settings) {
  const invert = settings.sortType.contains("_DESC") ? -1 : 1;
  switch (settings.sortType) {
   case "DISPNAME_ASC":
   case "DISPNAME_DESC":
    return (a, b) => compare(a.displayName, b.displayName) * invert;

   case "FULLPATH_ASC":
   case "FULLPATH_DESC":
    return (a, b) => compare(a.path, b.path) * invert;

   case "MTIME_ASC":
   case "MTIME_DESC":
    return (a, b) => (a.mtime - b.mtime) * invert;

   case "CTIME_ASC":
   case "CTIME_DESC":
    return (a, b) => (a.ctime - b.ctime) * invert;

   case "NAME_ASC":
   case "NAME_DESC":
    return (a, b) => compare(a.filename, b.filename) * invert;

   default:
    console.warn("Compare method (items) corrupted");
    return (a, b) => compare(a.displayName, b.displayName) * invert;
  }
}

function onElement(el, event2, selector, callback, options) {
  el.on(event2, selector, callback, options);
  return () => el.off(event2, selector, callback, options);
}

var TagFolderPlugin5 = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.settings = {
      ...DEFAULT_SETTINGS
    };
    this.expandedFolders = [ "root" ];
    this.currentOpeningFile = "";
    this.searchString = "";
    this.allViewItems = [];
    this.allViewItemsByLink = [];
    this.compareItems = (_, __) => 0;
    this.focusFile = (path, specialKey) => {
      if (this.currentOpeningFile == path) return;
      const _targetFile = this.app.vault.getAbstractFileByPath(path), targetFile = _targetFile instanceof import_obsidian8.TFile ? _targetFile : this.app.vault.getFiles().find(f => f.path === path);
      if (targetFile) if (specialKey) this.app.workspace.openLinkText(targetFile.path, targetFile.path, "tab"); else this.app.workspace.openLinkText(targetFile.path, targetFile.path);
    };
    this.fileCaches = [];
    this.oldFileCache = "";
    this.parsedFileCache = new Map;
    this.lastSettings = "";
    this.lastSearchString = "";
    this.processingFileInfo = false;
    this.loadFileQueue = [];
    this.loadFileTimer = void 0;
    this.tagInfo = {};
    this.tagInfoFrontMatterBuffer = {};
    this.skipOnce = false;
    this.tagInfoBody = "";
  }
  getView() {
    for (const leaf of this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER)) {
      const view = leaf.view;
      if (view instanceof TagFolderView) return view;
    }
    return null;
  }
  getLinkView() {
    for (const leaf of this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER_LINK)) {
      const view = leaf.view;
      if (view instanceof TagFolderView) return view;
    }
    return null;
  }
  hoverPreview(e, path) {
    this.app.workspace.trigger("hover-link", {
      event: e,
      source: "file-explorer",
      hoverParent: this,
      targetEl: e.target,
      linktext: path
    });
  }
  setSearchString(search) {
    searchString.set(search);
  }
  getFileTitle(file) {
    if (!this.settings.useTitle) return file.basename;
    const metadata = this.app.metadataCache.getCache(file.path);
    if ((null == metadata ? void 0 : metadata.frontmatter) && this.settings.frontmatterKey) {
      const d = dotted(metadata.frontmatter, this.settings.frontmatterKey);
      if (d) return `${d}`;
    }
    if (null == metadata ? void 0 : metadata.headings) {
      const h1 = metadata.headings.find(e => 1 == e.level);
      if (h1) return h1.heading;
    }
    return file.basename;
  }
  getDisplayName(file) {
    const filename = this.getFileTitle(file) || file.basename;
    if ("NAME" == this.settings.displayMethod) return filename;
    const path = file.path.split("/");
    path.pop();
    const displayPath = path.join("/");
    if ("NAME : PATH" == this.settings.displayMethod) return `${filename} : ${displayPath}`;
    if ("PATH/NAME" == this.settings.displayMethod) return `${displayPath}/${filename}`; else return filename;
  }
  async onload() {
    await this.loadSettings();
    this.hoverPreview = this.hoverPreview.bind(this);
    this.modifyFile = this.modifyFile.bind(this);
    this.setSearchString = this.setSearchString.bind(this);
    this.openScrollView = this.openScrollView.bind(this);
    this.loadFileInfo = (0, import_obsidian8.debounce)(this.loadFileInfo.bind(this), this.settings.scanDelay, true);
    pluginInstance.set(this);
    this.registerView(VIEW_TYPE_TAGFOLDER, leaf => new TagFolderView(leaf, this, "tags"));
    this.registerView(VIEW_TYPE_TAGFOLDER_LINK, leaf => new TagFolderView(leaf, this, "links"));
    this.registerView(VIEW_TYPE_TAGFOLDER_LIST, leaf => new TagFolderList(leaf, this));
    this.registerView(VIEW_TYPE_SCROLL, leaf => new ScrollView(leaf, this));
    this.app.workspace.onLayoutReady(async () => {
      this.loadFileInfo();
      if (this.settings.alwaysOpen) {
        await this.initView();
        await this.activateView();
      }
      if (this.settings.useTagInfo) await this.loadTagInfo();
    });
    this.addCommand({
      id: "tagfolder-open",
      name: "Show Tag Folder",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "tagfolder-link-open",
      name: "Show Link Folder",
      callback: () => {
        this.activateViewLink();
      }
    });
    this.addCommand({
      id: "tagfolder-rebuild-tree",
      name: "Force Rebuild",
      callback: () => {
        this.refreshAllTree();
      }
    });
    this.addCommand({
      id: "tagfolder-create-similar",
      name: "Create a new note with the same tags",
      editorCallback: async (editor, view) => {
        var _a3;
        const file = null == view ? void 0 : view.file;
        if (!file) return;
        const cache = this.app.metadataCache.getFileCache(file);
        if (!cache) return;
        const tagsWithoutPrefix = (null != (_a3 = (0, import_obsidian8.getAllTags)(cache)) ? _a3 : []).map(e => trimPrefix(e, "#"));
        await this.createNewNote(tagsWithoutPrefix);
      }
    });
    this.metadataCacheChanged = this.metadataCacheChanged.bind(this);
    this.watchWorkspaceOpen = this.watchWorkspaceOpen.bind(this);
    this.metadataCacheResolve = this.metadataCacheResolve.bind(this);
    this.metadataCacheResolved = this.metadataCacheResolved.bind(this);
    this.loadFileInfo = this.loadFileInfo.bind(this);
    this.registerEvent(this.app.metadataCache.on("changed", this.metadataCacheChanged));
    this.registerEvent(this.app.metadataCache.on("resolve", this.metadataCacheResolve));
    this.registerEvent(this.app.metadataCache.on("resolved", this.metadataCacheResolved));
    this.refreshAllTree = this.refreshAllTree.bind(this);
    this.refreshTree = this.refreshTree.bind(this);
    this.registerEvent(this.app.vault.on("rename", this.refreshTree));
    this.registerEvent(this.app.vault.on("delete", this.refreshTree));
    this.registerEvent(this.app.vault.on("modify", this.modifyFile));
    this.registerEvent(this.app.workspace.on("file-open", this.watchWorkspaceOpen));
    this.watchWorkspaceOpen(this.app.workspace.getActiveFile());
    this.addSettingTab(new TagFolderSettingTab(this.app, this));
    maxDepth.set(this.settings.expandLimit);
    searchString.subscribe(search => {
      this.searchString = search;
      this.refreshAllTree();
    });
    const setTagSearchString = (event2, tagString) => {
      if (tagString) {
        const regExpTagStr = new RegExp(`(^|\\s)${tagString.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}(\\s|$)`, "u"), regExpTagStrInv = new RegExp(`(^|\\s)-${tagString.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}(\\s|$)`, "u");
        if (event2.altKey) return; else if (event2.ctrlKey && event2.shiftKey) {
          if (this.searchString.match(regExpTagStr)) this.setSearchString(this.searchString.replace(regExpTagStr, "")); else if (!this.searchString.match(regExpTagStrInv)) this.setSearchString(this.searchString + (0 == this.searchString.length ? "" : " ") + `-${tagString}`);
        } else if (event2.ctrlKey) {
          if (this.searchString.match(regExpTagStrInv)) this.setSearchString(this.searchString.replace(regExpTagStrInv, "")); else if (!this.searchString.match(regExpTagStr)) this.setSearchString(this.searchString + (0 == this.searchString.length ? "" : " ") + `${tagString}`);
        } else this.setSearchString(tagString);
        event2.preventDefault();
        event2.stopPropagation();
      }
    };
    let metadataTagClickTimer = null;
    this.register(onElement(document, "click", '.metadata-property[data-property-key="tags"] .multi-select-pill-content span, .metadata-property[data-property-key="tags"] .multi-select-pill', (event2, targetEl) => {
      if (this.settings.overrideTagClicking) if (!event2.target.closest(".multi-select-pill-remove-button")) if (!(event2.detail > 1)) {
        event2.preventDefault();
        event2.stopPropagation();
        event2.stopImmediatePropagation();
        if (metadataTagClickTimer) {
          window.clearTimeout(metadataTagClickTimer);
          metadataTagClickTimer = null;
        }
        metadataTagClickTimer = window.setTimeout(() => {
          var _a3;
          metadataTagClickTimer = null;
          let tagElement = targetEl;
          if (targetEl.classList.contains("multi-select-pill")) {
            const span = targetEl.querySelector(".multi-select-pill-content span");
            if (span instanceof HTMLElement) tagElement = span;
          }
          let tagString = tagElement.innerText.trim();
          if (tagString.startsWith("#")) tagString = tagString.substring(1);
          if (tagString) {
            setTagSearchString(event2, tagString);
            const leaf = null == (_a3 = this.getView()) ? void 0 : _a3.leaf;
            if (leaf) this.app.workspace.revealLeaf(leaf);
          }
        }, 200);
      } else if (metadataTagClickTimer) {
        window.clearTimeout(metadataTagClickTimer);
        metadataTagClickTimer = null;
      }
    }, {
      capture: true
    }));
    this.register(onElement(document, "click", 'a.tag[href^="#"]', (event2, targetEl) => {
      var _a3;
      if (!this.settings.overrideTagClicking) return;
      if (targetEl.closest('.metadata-property[data-property-key="tags"]')) return;
      const tagString = targetEl.innerText.substring(1);
      if (tagString) {
        setTagSearchString(event2, tagString);
        const leaf = null == (_a3 = this.getView()) ? void 0 : _a3.leaf;
        if (leaf) this.app.workspace.revealLeaf(leaf);
      }
    }, {
      capture: true
    }));
    this.register(onElement(document, "click", "span.cm-hashtag.cm-meta", (event2, targetEl) => {
      var _a3;
      if (!this.settings.overrideTagClicking) return;
      let enumTags = targetEl, tagString = "";
      for (;!enumTags.classList.contains("cm-hashtag-begin"); ) {
        enumTags = enumTags.previousElementSibling;
        if (!enumTags) {
          console.log("Error! start tag not found.");
          return;
        }
      }
      do {
        if (enumTags instanceof HTMLElement) {
          tagString += enumTags.innerText;
          if (enumTags.classList.contains("cm-hashtag-end")) break;
        }
        enumTags = enumTags.nextElementSibling;
      } while (enumTags);
      tagString = tagString.substring(1);
      setTagSearchString(event2, tagString);
      const leaf = null == (_a3 = this.getView()) ? void 0 : _a3.leaf;
      if (leaf) this.app.workspace.revealLeaf(leaf);
    }, {
      capture: true
    }));
    selectedTags.subscribe(newTags => {
      this.openListView(newTags);
    });
  }
  watchWorkspaceOpen(file) {
    if (file) this.currentOpeningFile = file.path; else this.currentOpeningFile = "";
    currentFile.set(this.currentOpeningFile);
  }
  metadataCacheChanged(file) {
    this.loadFileInfoAsync(file);
  }
  metadataCacheResolve(file) {
    if (null != this.getLinkView()) this.loadFileInfoAsync(file);
  }
  metadataCacheResolved() {
    if (null != this.getLinkView()) ;
  }
  refreshTree(file, oldName) {
    if (oldName) this.refreshAllTree(); else if (file instanceof import_obsidian8.TFile) this.loadFileInfo(file);
  }
  refreshAllTree() {
    this.loadFileInfo();
  }
  getFileCacheLinks(file) {
    const cachedLinks = this.app.metadataCache.resolvedLinks;
    return [ ...(null == this.getLinkView() ? [] : parseAllReference(cachedLinks, file.path, this.settings.linkConfig)).filter(e => e.endsWith(".md")).map(e => `${e}`) ];
  }
  getFileCacheData(file) {
    const metadata = this.app.metadataCache.getFileCache(file);
    if (!metadata) return false; else return {
      file,
      links: this.getFileCacheLinks(file),
      tags: (0, import_obsidian8.getAllTags)(metadata) || []
    };
  }
  updateFileCachesAll() {
    const caches = [ ...this.app.vault.getMarkdownFiles(), ...this.app.vault.getAllLoadedFiles().filter(e => "extension" in e && "canvas" == e.extension) ].filter(file => {
      var _a3;
      return null != (_a3 = this.parsedFileCache.get(file.path)) ? _a3 : 0 != file.stat.mtime;
    }).map(entry => this.getFileCacheData(entry)).filter(e => false !== e);
    this.fileCaches = [ ...caches ];
    return this.isFileCacheChanged();
  }
  isFileCacheChanged() {
    const fileCacheDump = JSON.stringify(this.fileCaches.map(e => ({
      path: e.file.path,
      links: e.links,
      tags: e.tags
    })));
    if (this.oldFileCache == fileCacheDump) return false; else {
      this.oldFileCache = fileCacheDump;
      return true;
    }
  }
  updateFileCaches(diffs = []) {
    let anyUpdated = false;
    if (0 == this.fileCaches.length || 0 == diffs.length) return this.updateFileCachesAll(); else {
      const processDiffs = [ ...diffs ];
      let newCaches = [ ...this.fileCaches ], diff = processDiffs.shift();
      do {
        const procDiff = diff;
        if (!procDiff) break;
        const old = newCaches.find(fileCache => fileCache.file.path == procDiff.path);
        if (old) newCaches = newCaches.filter(fileCache => fileCache !== old);
        const newCache = this.getFileCacheData(procDiff);
        if (newCache) {
          if (null != this.getLinkView()) {
            const oldLinks = (null == old ? void 0 : old.links) || [], newLinks = newCache.links, diffs2 = unique([ ...oldLinks, ...newLinks ]).filter(link2 => !oldLinks.contains(link2) || !newLinks.contains(link2));
            for (const filename of diffs2) {
              const file = this.app.vault.getAbstractFileByPath(filename);
              if (file instanceof import_obsidian8.TFile) processDiffs.push(file);
            }
          }
          newCaches.push(newCache);
        }
        anyUpdated = anyUpdated || JSON.stringify(fileCacheToCompare(old)) != JSON.stringify(fileCacheToCompare(newCache));
        diff = processDiffs.shift();
      } while (void 0 !== diff);
      this.fileCaches = newCaches;
    }
    return anyUpdated;
  }
  async getItemsList(mode) {
    const items = [], ignoreDocTags = this.settings.ignoreDocTags.toLowerCase().replace(/[\n ]/g, "").split(","), ignoreTags = this.settings.ignoreTags.toLowerCase().replace(/[\n ]/g, "").split(","), ignoreFolders = this.settings.ignoreFolders.toLowerCase().replace(/\n/g, "").split(",").map(e => e.trim()).filter(e => !!e), targetFolders = this.settings.targetFolders.toLowerCase().replace(/\n/g, "").split(",").map(e => e.trim()).filter(e => !!e), searchItems = this.searchString.toLowerCase().split("|").map(ee => ee.split(" ").map(e => e.trim())), today = Date.now(), archiveTags = this.settings.archiveTags.toLowerCase().replace(/[\n ]/g, "").split(",");
    for (const fileCache of this.fileCaches) {
      if (targetFolders.length > 0 && !targetFolders.some(e => "" != e && fileCache.file.path.toLowerCase().startsWith(e))) continue;
      if (ignoreFolders.some(e => "" != e && fileCache.file.path.toLowerCase().startsWith(e))) continue;
      await doEvents();
      const tagRedirectList = {};
      if (this.settings.useTagInfo && this.tagInfo) for (const [key2, taginfo] of Object.entries(this.tagInfo)) if (null == taginfo ? void 0 : taginfo.redirect) tagRedirectList[key2] = taginfo.redirect;
      let allTags = [];
      if ("tag" == mode) {
        const allTagsDocs = unique(fileCache.tags);
        allTags = unique(allTagsDocs.map(e => e.substring(1)).map(e => e in tagRedirectList ? tagRedirectList[e] : e));
      } else allTags = unique(fileCache.links);
      if (this.settings.disableNestedTags && "tag" == mode) allTags = allTags.map(e => e.split("/")).flat();
      if (0 == allTags.length) if ("tag" == mode) allTags = [ "_untagged" ]; else if ("link" == mode) allTags = [ "_unlinked" ];
      if ("canvas" == fileCache.file.extension) allTags.push("_VIRTUAL_TAG_CANVAS");
      if (this.settings.useVirtualTag) {
        const disp = secondsToFreshness(today - fileCache.file.stat.mtime);
        allTags.push(`_VIRTUAL_TAG_FRESHNESS/${disp}`);
      }
      if (this.settings.displayFolderAsTag) {
        const path = [ "_VIRTUAL_TAG_FOLDER", ...fileCache.file.path.split("/") ];
        path.pop();
        if (path.length > 0) allTags.push(`${path.join("/")}`);
      }
      allTags = uniqueCaseIntensive(allTags.map(e => e in tagRedirectList ? tagRedirectList[e] : e));
      if (allTags.some(tag2 => ignoreDocTags.contains(tag2.toLowerCase()))) continue;
      if (searchItems.map(searchItem => {
        let bx = false;
        if (0 == allTags.length) return false;
        for (const searchSrc of searchItem) {
          let search = searchSrc, func = "contains";
          if (search.startsWith("#")) {
            search = search.substring(1);
            func = "startsWith";
          }
          if (search.startsWith("-")) bx = bx || allTags.some(tag2 => tag2.toLowerCase()[func](search.substring(1))); else bx = bx || allTags.every(tag2 => !tag2.toLowerCase()[func](search));
        }
        return bx;
      }).every(e => e)) continue;
      allTags = allTags.filter(tag2 => !ignoreTags.contains(tag2.toLowerCase()));
      const links = [ ...fileCache.links ];
      if (0 == links.length) links.push("_unlinked");
      if (this.settings.disableNarrowingDown && "tag" == mode) {
        const archiveTagsMatched = allTags.filter(e => archiveTags.contains(e.toLowerCase())), targetTags = 0 == archiveTagsMatched.length ? allTags : archiveTagsMatched;
        for (const tags of targetTags) items.push({
          tags: [ tags ],
          extraTags: allTags.filter(e => e != tags),
          path: fileCache.file.path,
          displayName: this.getDisplayName(fileCache.file),
          ancestors: [],
          mtime: fileCache.file.stat.mtime,
          ctime: fileCache.file.stat.ctime,
          filename: fileCache.file.basename,
          links
        });
      } else items.push({
        tags: allTags,
        extraTags: [],
        path: fileCache.file.path,
        displayName: this.getDisplayName(fileCache.file),
        ancestors: [],
        mtime: fileCache.file.stat.mtime,
        ctime: fileCache.file.stat.ctime,
        filename: fileCache.file.basename,
        links
      });
    }
    return items;
  }
  loadFileInfo(diff) {
    this.loadFileInfoAsync(diff).then(e => {});
  }
  isSettingChanged() {
    const strSetting = JSON.stringify(this.settings), isSettingChanged = strSetting != this.lastSettings, isSearchStringModified = this.searchString != this.lastSearchString;
    if (isSettingChanged) this.lastSettings = strSetting;
    if (isSearchStringModified) this.lastSearchString = this.searchString;
    return isSearchStringModified || isSettingChanged;
  }
  async loadFileInfos(diffs) {
    if (!this.processingFileInfo) try {
      this.processingFileInfo = true;
      const cacheUpdated = this.updateFileCaches(diffs);
      if (this.isSettingChanged() || cacheUpdated) {
        appliedFiles.set(diffs.map(e => e.path));
        await this.applyFileInfoToView();
      }
      await this.applyUpdateIntoScroll(diffs);
      const af = this.app.workspace.getActiveFile();
      if (af && this.currentOpeningFile != af.path) {
        this.currentOpeningFile = af.path;
        currentFile.set(this.currentOpeningFile);
      }
    } finally {
      this.processingFileInfo = false;
    } else diffs.forEach(e => {
      this.loadFileInfoAsync(e);
    });
  }
  async applyFileInfoToView() {
    const itemsSorted = (await this.getItemsList("tag")).sort(this.compareItems);
    this.allViewItems = itemsSorted;
    allViewItems.set(this.allViewItems);
    if (null != this.getLinkView()) {
      const itemsLink = await this.getItemsList("link");
      updateItemsLinkMap(itemsLink);
      const itemsLinkSorted = itemsLink.sort(this.compareItems);
      this.allViewItemsByLink = itemsLinkSorted;
      allViewItemsByLink.set(this.allViewItemsByLink);
    }
  }
  async loadFileInfoAsync(diff) {
    if (diff) {
      if (diff && this.loadFileQueue.some(e => e.path == (null == diff ? void 0 : diff.path))) ; else this.loadFileQueue.push(diff);
      if (this.loadFileTimer) clearTimeout(this.loadFileTimer);
      this.loadFileTimer = setTimeout(() => {
        if (0 === this.loadFileQueue.length) ; else {
          const diffs = [ ...this.loadFileQueue ];
          this.loadFileQueue = [];
          this.loadFileInfos(diffs);
        }
      }, 200);
    } else {
      this.loadFileQueue = [];
      if (this.loadFileTimer) {
        clearTimeout(this.loadFileTimer);
        this.loadFileTimer = void 0;
      }
      await this.loadFileInfos([]);
    }
  }
  onunload() {
    pluginInstance.set(void 0);
  }
  async openScrollView(leaf, title, tagPath, files) {
    if (!leaf) leaf = this.app.workspace.getLeaf("split");
    await leaf.setViewState({
      type: VIEW_TYPE_SCROLL,
      active: true,
      state: {
        files: files.map(e => ({
          path: e
        })),
        title,
        tagPath
      }
    });
    this.app.workspace.revealLeaf(leaf);
  }
  async applyUpdateIntoScroll(files) {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_SCROLL);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (!view) continue;
      const viewState = leaf.getViewState(), scrollViewState = null == view ? void 0 : view.getScrollViewState();
      if (!viewState || !scrollViewState) continue;
      const viewStat = {
        ...viewState,
        state: {
          ...scrollViewState
        }
      };
      for (const file of files) if (file && view.isFileOpened(file.path)) {
        const newStat = {
          ...viewStat,
          state: {
            ...viewStat.state,
            files: viewStat.state.files.map(e => e.path == file.path ? {
              path: file.path
            } : e)
          }
        };
        await leaf.setViewState(newStat);
      }
      const tags = viewStat.state.tagPath.split(", ");
      let matchedFiles = this.allViewItems;
      for (const tag2 of tags) matchedFiles = matchedFiles.filter(item => item.tags.map(tag3 => tag3.toLowerCase()).some(itemTag => itemTag == tag2.toLowerCase() || (itemTag + "/").startsWith(tag2.toLowerCase() + (tag2.endsWith("/") ? "" : "/"))));
      const newFilesArray = matchedFiles.map(e => e.path);
      if (newFilesArray.sort().join("-") != viewStat.state.files.map(e => e.path).sort().join("-")) {
        const newStat = {
          ...viewStat,
          state: {
            ...viewStat.state,
            files: newFilesArray.map(path => {
              const old = viewStat.state.files.find(e => e.path == path);
              if (old) return old; else return {
                path
              };
            })
          }
        };
        await leaf.setViewState(newStat);
      }
    }
  }
  async _initTagView() {
    var _a3;
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER);
    if (0 == leaves.length) await (null == (_a3 = this.app.workspace.getLeftLeaf(false)) ? void 0 : _a3.setViewState({
      type: VIEW_TYPE_TAGFOLDER,
      state: {
        treeViewType: "tags"
      }
    })); else {
      const newState = leaves[0].getViewState();
      await leaves[0].setViewState({
        type: VIEW_TYPE_TAGFOLDER,
        state: {
          ...newState,
          treeViewType: "tags"
        }
      });
    }
  }
  async _initLinkView() {
    var _a3;
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER_LINK);
    if (0 == leaves.length) await (null == (_a3 = this.app.workspace.getLeftLeaf(false)) ? void 0 : _a3.setViewState({
      type: VIEW_TYPE_TAGFOLDER_LINK,
      state: {
        treeViewType: "links"
      }
    })); else {
      const newState = leaves[0].getViewState();
      await leaves[0].setViewState({
        type: VIEW_TYPE_TAGFOLDER_LINK,
        state: {
          ...newState,
          treeViewType: "links"
        }
      });
    }
  }
  async initView() {
    this.loadFileInfo();
    await this._initTagView();
  }
  async initLinkView() {
    this.loadFileInfo();
    await this._initLinkView();
  }
  async activateView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER);
    await this.initView();
    if (leaves.length > 0) await this.app.workspace.revealLeaf(leaves[0]);
  }
  async activateViewLink() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER_LINK);
    await this.initLinkView();
    if (leaves.length > 0) await this.app.workspace.revealLeaf(leaves[0]);
  }
  async modifyFile(file) {
    if (this.settings.useTagInfo) if (!this.skipOnce) {
      if (file.name == this.getTagInfoFilename()) await this.loadTagInfo();
    } else this.skipOnce = false;
  }
  getTagInfoFilename() {
    return (0, import_obsidian8.normalizePath)(this.settings.tagInfo);
  }
  getTagInfoFile() {
    const file = this.app.vault.getAbstractFileByPath(this.getTagInfoFilename());
    if (file instanceof import_obsidian8.TFile) return file; else return null;
  }
  applyTagInfo() {
    if (null != this.tagInfo) if (this.settings.useTagInfo) tagInfo.set(this.tagInfo);
  }
  async loadTagInfo() {
    if (!this.settings.useTagInfo) return;
    if (null == this.tagInfo) this.tagInfo = {};
    const file = this.getTagInfoFile();
    if (null == file) return;
    const data = await this.app.vault.read(file);
    try {
      const bodyStartIndex = data.indexOf("\n---");
      if (!data.startsWith("---") || -1 === bodyStartIndex) return;
      const yaml = data.substring(3, bodyStartIndex), yamlData = (0, import_obsidian8.parseYaml)(yaml), keys = Object.keys(yamlData);
      this.tagInfoBody = data.substring(bodyStartIndex + 5);
      this.tagInfoFrontMatterBuffer = yamlData;
      const newTagInfo = {};
      for (const key2 of keys) {
        const w = yamlData[key2];
        if (!w) continue;
        if ("object" != typeof w) continue;
        const keys2 = [ "key", "mark", "alt", "redirect" ], entries = Object.entries(w).filter(([key3]) => keys2.some(e => key3.contains(e)));
        if (0 != entries.length) newTagInfo[key2] = Object.fromEntries(entries);
      }
      this.tagInfo = newTagInfo;
      this.applyTagInfo();
    } catch (ex) {
      console.log(ex);
    }
  }
  async saveTagInfo() {
    if (!this.settings.useTagInfo) return;
    if (null == this.tagInfo) return;
    let file = this.getTagInfoFile();
    if (null == file) file = await this.app.vault.create(this.getTagInfoFilename(), "");
    await this.app.fileManager.processFrontMatter(file, matter => {
      const ti = Object.entries(this.tagInfo);
      for (const [key2, value] of ti) if (void 0 === value) delete matter[key2]; else matter[key2] = value;
    });
  }
  async refreshAllViewItems() {
    this.parsedFileCache.clear();
    const itemsSorted = (await this.getItemsList("tag")).sort(this.compareItems);
    this.allViewItems = itemsSorted;
    allViewItems.set(this.allViewItems);
    const itemsLinkSorted = (await this.getItemsList("link")).sort(this.compareItems);
    this.allViewItemsByLink = itemsLinkSorted;
    allViewItemsByLink.set(this.allViewItemsByLink);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    await this.loadTagInfo();
    tagFolderSetting.set(this.settings);
    this.compareItems = getCompareMethodItems(this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.saveTagInfo();
    tagFolderSetting.set(this.settings);
    this.compareItems = getCompareMethodItems(this.settings);
    this.refreshAllViewItems();
  }
  async openListView(tagSrc) {
    var _a3, _b3;
    if (!tagSrc) return;
    const tags = "root" == tagSrc.first() ? tagSrc.slice(1) : tagSrc;
    let theLeaf;
    for (const leaf of this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER_LIST)) {
      const state2 = leaf.getViewState();
      if (null == (_a3 = state2.state) ? void 0 : _a3.tags) {
        if (state2.state.tags.slice().sort().join("-") == tags.slice().sort().join("-")) {
          this.app.workspace.setActiveLeaf(leaf, {
            focus: true
          });
          return;
        }
        if (state2.pinned) ; else theLeaf = leaf;
      }
    }
    if (!theLeaf) {
      const parent = null == (_b3 = this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER)) ? void 0 : _b3.first();
      if (!parent) return;
      switch (this.settings.showListIn) {
       case "CURRENT_PANE":
        theLeaf = this.app.workspace.getLeaf();
        break;

       case "SPLIT_PANE":
        theLeaf = this.app.workspace.getLeaf("split", "horizontal");
        break;

       case "":
       default:
        if (!import_obsidian8.Platform.isMobile) theLeaf = this.app.workspace.createLeafBySplit(parent, "horizontal", false); else theLeaf = this.app.workspace.getLeftLeaf(false);
        break;
      }
    }
    const title = tags.map(e => e.split("/").map(ee => renderSpecialTag(ee)).join("/")).join(" ");
    await theLeaf.setViewState({
      type: VIEW_TYPE_TAGFOLDER_LIST,
      active: true,
      state: {
        tags,
        title
      }
    });
    await this.app.workspace.revealLeaf(theLeaf);
  }
  async createNewNote(tags) {
    const expandedTagsAll = ancestorToLongestTag(ancestorToTags(joinPartialPath(removeIntermediatePath(null != tags ? tags : [])))).map(e => trimTrailingSlash(e)), expandedTags = expandedTagsAll.map(e => e.split("/").filter(ee => !isSpecialTag(ee)).join("/")).filter(e => "" != e).map(e => "#" + e).join(" ").trim(), ww = await this.app.fileManager.createAndOpenMarkdownFile();
    if (this.settings.useFrontmatterTagsForNewNotes) await this.app.fileManager.processFrontMatter(ww, matter => {
      var _a3;
      matter.tags = null != (_a3 = matter.tags) ? _a3 : [];
      matter.tags = expandedTagsAll.filter(e => !isSpecialTag(e)).filter(e => matter.tags.indexOf(e) < 0).concat(matter.tags);
    }); else await this.app.vault.append(ww, expandedTags);
  }
}, TagFolderSettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  hide() {
    this.plugin.loadFileInfo();
  }
  display() {
    const {containerEl} = this;
    containerEl.empty();
    containerEl.createEl("h2", {
      text: "Behavior"
    });
    new import_obsidian8.Setting(containerEl).setName("Always Open").setDesc("Place TagFolder on the left pane and activate it at every Obsidian launch").addToggle(toggle => toggle.setValue(this.plugin.settings.alwaysOpen).onChange(async value => {
      this.plugin.settings.alwaysOpen = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Use pinning").setDesc("When this feature is enabled, the pin information is saved in the file set in the next configuration.").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.useTagInfo).onChange(async value => {
        this.plugin.settings.useTagInfo = value;
        if (this.plugin.settings.useTagInfo) await this.plugin.loadTagInfo();
        await this.plugin.saveSettings();
        pi.setDisabled(!value);
      });
    });
    const pi = new import_obsidian8.Setting(containerEl).setName("Pin information file").setDisabled(!this.plugin.settings.useTagInfo).addText(text2 => {
      text2.setValue(this.plugin.settings.tagInfo).onChange(async value => {
        this.plugin.settings.tagInfo = value;
        if (this.plugin.settings.useTagInfo) await this.plugin.loadTagInfo();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName("Disable narrowing down").setDesc("When this feature is enabled, relevant tags will be shown with the title instead of making a sub-structure.").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.disableNarrowingDown).onChange(async value => {
        this.plugin.settings.disableNarrowingDown = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h2", {
      text: "Files"
    });
    new import_obsidian8.Setting(containerEl).setName("Display method").setDesc("How to show a title of files").addDropdown(dropdown => dropdown.addOptions({
      "PATH/NAME": "PATH/NAME",
      NAME: "NAME",
      "NAME : PATH": "NAME : PATH"
    }).setValue(this.plugin.settings.displayMethod).onChange(async value => {
      this.plugin.settings.displayMethod = value;
      this.plugin.loadFileInfo();
      await this.plugin.saveSettings();
    }));
    const setOrderMethod = async (key2, order) => {
      const oldSetting = this.plugin.settings.sortType.split("_");
      if (!key2) key2 = oldSetting[0];
      if (!order) order = oldSetting[1];
      this.plugin.settings.sortType = `${key2}_${order}`;
      await this.plugin.saveSettings();
    };
    new import_obsidian8.Setting(containerEl).setName("Order method").setDesc("how to order items").addDropdown(dd => {
      dd.addOptions(OrderKeyItem).setValue(this.plugin.settings.sortType.split("_")[0]).onChange(key2 => setOrderMethod(key2, void 0));
    }).addDropdown(dd => {
      dd.addOptions(OrderDirection).setValue(this.plugin.settings.sortType.split("_")[1]).onChange(order => setOrderMethod(void 0, order));
    });
    new import_obsidian8.Setting(containerEl).setName("Prioritize items which are not contained in sub-folder").setDesc("If this has been enabled, the items which have no more extra tags are first.").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.sortExactFirst).onChange(async value => {
        this.plugin.settings.sortExactFirst = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName("Use title").setDesc("Use value in the frontmatter or first level one heading for `NAME`.").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.useTitle).onChange(async value => {
        this.plugin.settings.useTitle = value;
        fpath.setDisabled(!value);
        await this.plugin.saveSettings();
      });
    });
    const fpath = new import_obsidian8.Setting(containerEl).setName("Frontmatter path").setDisabled(!this.plugin.settings.useTitle).addText(text2 => {
      text2.setValue(this.plugin.settings.frontmatterKey).onChange(async value => {
        this.plugin.settings.frontmatterKey = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h2", {
      text: "Tags"
    });
    const setOrderMethodTag = async (key2, order) => {
      const oldSetting = this.plugin.settings.sortTypeTag.split("_");
      if (!key2) key2 = oldSetting[0];
      if (!order) order = oldSetting[1];
      this.plugin.settings.sortTypeTag = `${key2}_${order}`;
      await this.plugin.saveSettings();
    };
    new import_obsidian8.Setting(containerEl).setName("Order method").setDesc("how to order tags").addDropdown(dd => {
      dd.addOptions(OrderKeyTag).setValue(this.plugin.settings.sortTypeTag.split("_")[0]).onChange(key2 => setOrderMethodTag(key2, void 0));
    }).addDropdown(dd => {
      dd.addOptions(OrderDirection).setValue(this.plugin.settings.sortTypeTag.split("_")[1]).onChange(order => setOrderMethodTag(void 0, order));
    });
    new import_obsidian8.Setting(containerEl).setName("Use virtual tags").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.useVirtualTag).onChange(async value => {
        this.plugin.settings.useVirtualTag = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName("Display folder as tag").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.displayFolderAsTag).onChange(async value => {
        this.plugin.settings.displayFolderAsTag = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName("Store tags in frontmatter for new notes").setDesc("Otherwise, tags are stored with #hashtags at the top of the note").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.useFrontmatterTagsForNewNotes).onChange(async value => {
        this.plugin.settings.useFrontmatterTagsForNewNotes = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h2", {
      text: "Actions"
    });
    new import_obsidian8.Setting(containerEl).setName("Search tags inside TagFolder when clicking tags").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.overrideTagClicking).onChange(async value => {
        this.plugin.settings.overrideTagClicking = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName("List files in a separated pane").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.useMultiPaneList).onChange(async value => {
        this.plugin.settings.useMultiPaneList = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName("Show list in").setDesc("This option applies to the newly opened list").addDropdown(dropdown => {
      dropdown.addOptions(enumShowListIn).setValue(this.plugin.settings.showListIn).onChange(async value => {
        this.plugin.settings.showListIn = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h2", {
      text: "Arrangements"
    });
    new import_obsidian8.Setting(containerEl).setName("Hide Items").setDesc("Hide items on the landing or nested tags").addDropdown(dd => {
      dd.addOptions(HideItemsType).setValue(this.plugin.settings.hideItems).onChange(async key2 => {
        if ("NONE" == key2 || "DEDICATED_INTERMIDIATES" == key2 || "ALL_EXCEPT_BOTTOM" == key2) this.plugin.settings.hideItems = key2;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName("Merge redundant combinations").setDesc("When this feature is enabled, a/b and b/a are merged into a/b if there is no intermediates.").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.mergeRedundantCombination).onChange(async value => {
        this.plugin.settings.mergeRedundantCombination = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName("Do not simplify empty folders").setDesc("Keep empty folders, even if they can be simplified.").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.doNotSimplifyTags).onChange(async value => {
        this.plugin.settings.doNotSimplifyTags = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName("Do not treat nested tags as dedicated levels").setDesc("Treat nested tags as normal tags").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.disableNestedTags).onChange(async value => {
        this.plugin.settings.disableNestedTags = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName("Reduce duplicated parents in nested tags").setDesc("If enabled, #web/css, #web/javascript will merged into web -> css -> javascript").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.reduceNestedParent).onChange(async value => {
        this.plugin.settings.reduceNestedParent = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName("Keep untagged items on the root").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.expandUntaggedToRoot).onChange(async value => {
        this.plugin.settings.expandUntaggedToRoot = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h2", {
      text: "Link Folder"
    });
    new import_obsidian8.Setting(containerEl).setName("Use Incoming").setDesc("").addToggle(toggle => toggle.setValue(this.plugin.settings.linkConfig.incoming.enabled).onChange(async value => {
      this.plugin.settings.linkConfig.incoming.enabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Use Outgoing").setDesc("").addToggle(toggle => toggle.setValue(this.plugin.settings.linkConfig.outgoing.enabled).onChange(async value => {
      this.plugin.settings.linkConfig.outgoing.enabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Hide indirectly linked notes").setDesc("").addToggle(toggle => toggle.setValue(this.plugin.settings.linkShowOnlyFDR).onChange(async value => {
      this.plugin.settings.linkShowOnlyFDR = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Connect linked tree").setDesc("").addToggle(toggle => toggle.setValue(this.plugin.settings.linkCombineOtherTree).onChange(async value => {
      this.plugin.settings.linkCombineOtherTree = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", {
      text: "Filters"
    });
    new import_obsidian8.Setting(containerEl).setName("Target Folders").setDesc("If configured, the plugin will only target files in it.").addTextArea(text2 => text2.setValue(this.plugin.settings.targetFolders).setPlaceholder("study,documents/summary").onChange(async value => {
      this.plugin.settings.targetFolders = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Ignore Folders").setDesc("Ignore documents in specific folders.").addTextArea(text2 => text2.setValue(this.plugin.settings.ignoreFolders).setPlaceholder("template,list/standard_tags").onChange(async value => {
      this.plugin.settings.ignoreFolders = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Ignore note Tag").setDesc("If the note has the tag listed below, the note would be treated as there was not.").addTextArea(text2 => text2.setValue(this.plugin.settings.ignoreDocTags).setPlaceholder("test,test1,test2").onChange(async value => {
      this.plugin.settings.ignoreDocTags = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Ignore Tag").setDesc("Tags in the list would be treated as there were not.").addTextArea(text2 => text2.setValue(this.plugin.settings.ignoreTags).setPlaceholder("test,test1,test2").onChange(async value => {
      this.plugin.settings.ignoreTags = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Archive tags").setDesc("If configured, notes with these tags will be moved under the tag.").addTextArea(text2 => text2.setValue(this.plugin.settings.archiveTags).setPlaceholder("archived, discontinued").onChange(async value => {
      this.plugin.settings.archiveTags = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", {
      text: "Misc"
    });
    new import_obsidian8.Setting(containerEl).setName("Tag scanning delay").setDesc("Sets the delay for reflecting metadata changes to the tag tree. (Plugin reload is required.)").addText(text2 => {
      (text2 = text2.setValue(this.plugin.settings.scanDelay + "").onChange(async value => {
        const newDelay = Number.parseInt(value, 10);
        if (newDelay) {
          this.plugin.settings.scanDelay = newDelay;
          await this.plugin.saveSettings();
        }
      })).inputEl.setAttribute("type", "number");
      text2.inputEl.setAttribute("min", "250");
      return text2;
    });
    new import_obsidian8.Setting(containerEl).setName("Disable dragging tags").setDesc("The `Dragging tags` is using internal APIs. If something happens, please disable this once and try again.").addToggle(toggle => {
      toggle.setValue(this.plugin.settings.disableDragging).onChange(async value => {
        this.plugin.settings.disableDragging = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h2", {
      text: "Utilities"
    });
    new import_obsidian8.Setting(containerEl).setName("Dumping tags for reporting bugs").setDesc("If you want to open an issue to the GitHub, this information can be useful. and, also if you want to keep secrets about names of tags, you can use `disguised`.").addButton(button => button.setButtonText("Copy tags").setDisabled(false).onClick(async () => {
      const items = (await this.plugin.getItemsList("tag")).map(e => e.tags.filter(e2 => "_untagged" != e2)).filter(e => e.length);
      await navigator.clipboard.writeText(items.map(e => e.map(e2 => `#${e2}`).join(", ")).join("\n"));
      new import_obsidian8.Notice("Copied to clipboard");
    })).addButton(button => button.setButtonText("Copy disguised tags").setDisabled(false).onClick(async () => {
      const x = new Map;
      let i = 0;
      const items = (await this.plugin.getItemsList("tag")).map(e => e.tags.filter(e2 => "_untagged" != e2).map(e2 => e2.split("/").map(e3 => e3.startsWith("_VIRTUAL") ? e3 : x.has(e3) ? x.get(e3) : (x.set(e3, "tag" + i++), 
      i)).join("/")).filter(e2 => e2.length));
      await navigator.clipboard.writeText(items.map(e => e.map(e2 => `#${e2}`).join(", ")).join("\n"));
      new import_obsidian8.Notice("Copied to clipboard");
    }));
  }
};
/* nosourcemap */